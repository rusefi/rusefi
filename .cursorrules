# Instructions

During your interaction with the user, if you find anything reusable in this project (e.g. version of a library, model name), especially about a fix to a mistake you made or a correction you received, you should take note in the `Lessons` section in the `.cursorrules` file so you will not make the same mistake again. 

You should also use the `.cursorrules` file as a Scratchpad to organize your thoughts. Especially when you receive a new task, you should first review the content of the Scratchpad, clear old different task if necessary, first explain the task, and plan the steps you need to take to complete the task. You can use todo markers to indicate the progress, e.g.
[X] Task 1
[ ] Task 2

Also update the progress of the task in the Scratchpad when you finish a subtask.
Especially when you finished a milestone, it will help to improve your depth of task accomplishment to use the Scratchpad to reflect and plan.
The goal is to help you maintain a big picture as well as the progress of the task. Always refer to the Scratchpad when you plan the next step.

# Tools

Note all the tools are in python3. So in the case you need to do batch processing, you can always consult the python files and write your own script.

[NOTE TO CURSOR: Since no API key is configured, please ignore both the Screenshot Verification and LLM sections below.]
[NOTE TO USER: If you have configured or plan to configure an API key in the future, simply delete these two notice lines to enable these features.]

## Screenshot Verification

The screenshot verification workflow allows you to capture screenshots of web pages and verify their appearance using LLMs. The following tools are available:

1. Screenshot Capture:
```bash
venv/bin/python3 tools/screenshot_utils.py URL [--output OUTPUT] [--width WIDTH] [--height HEIGHT]
```

2. LLM Verification with Images:
```bash
venv/bin/python3 tools/llm_api.py --prompt "Your verification question" --provider {openai|anthropic} --image path/to/screenshot.png
```

Example workflow:
```python
from screenshot_utils import take_screenshot_sync
from llm_api import query_llm

# Take a screenshot

screenshot_path = take_screenshot_sync('https://example.com', 'screenshot.png')

# Verify with LLM

response = query_llm(
    "What is the background color and title of this webpage?",
    provider="openai",  # or "anthropic"
    image_path=screenshot_path
)
print(response)
```

## LLM

You always have an LLM at your side to help you with the task. For simple tasks, you could invoke the LLM by running the following command:
```
venv/bin/python3 ./tools/llm_api.py --prompt "What is the capital of France?" --provider "anthropic"
```

The LLM API supports multiple providers:
- OpenAI (default, model: gpt-4o)
- Azure OpenAI (model: configured via AZURE_OPENAI_MODEL_DEPLOYMENT in .env file, defaults to gpt-4o-ms)
- DeepSeek (model: deepseek-chat)
- Anthropic (model: claude-3-sonnet-20240229)
- Gemini (model: gemini-pro)
- Local LLM (model: Qwen/Qwen2.5-32B-Instruct-AWQ)

But usually it's a better idea to check the content of the file and use the APIs in the `tools/llm_api.py` file to invoke the LLM if needed.

## Web browser

You could use the `tools/web_scraper.py` file to scrape the web.
```bash
venv/bin/python3 ./tools/web_scraper.py --max-concurrent 3 URL1 URL2 URL3
```
This will output the content of the web pages.

## Search engine

You could use the `tools/search_engine.py` file to search the web.
```bash
venv/bin/python3 ./tools/search_engine.py "your search keywords"
```
This will output the search results in the following format:
```
URL: https://example.com
Title: This is the title of the search result
Snippet: This is a snippet of the search result
```
If needed, you can further use the `web_scraper.py` file to scrape the web page content.

# Lessons

## User Specified Lessons

- You have a python venv in ./venv. Always use (activate) it when doing python development. First, to check whether 'uv' is available, use `which uv`. If that's the case, first activate the venv, and then use `uv pip install` to install packages. Otherwise, fall back to `pip`.
- Include info useful for debugging in the program output.
- Read the file before you try to edit it.
- Due to Cursor's limit, when you use `git` and `gh` and need to submit a multiline commit message, first write the message in a file, and then use `git commit -F <filename>` or similar command to commit. And then remove the file. Include "[Cursor] " in the commit message and PR title.

## Cursor learned

- For search results, ensure proper handling of different character encodings (UTF-8) for international queries
- Add debug information to stderr while keeping the main output clean in stdout for better pipeline integration
- When using seaborn styles in matplotlib, use 'seaborn-v0_8' instead of 'seaborn' as the style name due to recent seaborn version changes
- Use 'gpt-4o' as the model name for OpenAI's GPT-4 with vision capabilities
- When searching for recent news, use the current year (2025) instead of previous years, or simply use the "recent" keyword to get the latest information
- **CRITICAL**: In rusefi Engine structure, wallFuel is NOT `engine->wallFuel[i]` (doesn't exist). The correct access is `engine->injectionEvents.elements[i].getWallFuel()` - each InjectionEvent has its own WallFuel instance
- **CRITICAL WALL WETTING TUNING**: Beta e tau t√™m comportamentos f√≠sicos espec√≠ficos que devem ser respeitados no tuning adaptativo:
  - **Beta (fra√ß√£o de impacto)**: Controla quanto combust√≠vel gruda nas paredes IMEDIATAMENTE durante transientes positivos (acelera√ß√£o)
  - **Tau (constante de evapora√ß√£o)**: Controla quanto tempo o combust√≠vel demora para evaporar das paredes, afeta resposta A LONGO PRAZO
  - **Tuning pr√°tico**: Beta √© ajustado observando resposta IMEDIATA p√≥s-acelera√ß√£o, tau √© ajustado observando resposta PROLONGADA
  - **Dire√ß√£o f√≠sica**: Lambda lean p√≥s-acelera√ß√£o ‚Üí aumentar beta; Lambda rich durante acelera√ß√£o prolongada ‚Üí diminuir tau
  - **Timing cr√≠tico**: Beta afeta os primeiros 100-200ms, tau afeta os pr√≥ximos 1-3 segundos ap√≥s transiente
- **CRITICAL TAU CORRECTION METHOD**: A corre√ß√£o de tau deve ser baseada na TEND√äNCIA/CURVA do lambda ao longo do tempo, N√ÉO na m√©dia:
  - **PROBLEMA**: Usar m√©dia do lambda pode mascarar problemas - ex: lambda rico no in√≠cio + lean no final = m√©dia boa, mas tau incorreto
  - **SOLU√á√ÉO CORRETA**: An√°lise de regress√£o linear para detectar slope/tend√™ncia do lambda durante fase prolongada
  - **F√≠sica**: Tau incorreto causa lambda inst√°vel ao longo do tempo (rico‚Üílean ou lean‚Üírich)
  - **Implementa√ß√£o**: `slope = (n*sumXY - sumX*sumY) / (n*sumX2 - sumX*sumX)` para detectar tend√™ncia
  - **Interpreta√ß√£o**: Slope positivo (lean crescente) ‚Üí tau muito baixo, aumentar tau; Slope negativo (rich crescente) ‚Üí tau muito alto, diminuir tau
  - **Threshold**: M√≠nimo 10 amostras e slope > 0.001f para corre√ß√£o significativa
  - **Vantagem**: Detecta problemas de tau mesmo quando m√©dia do lambda parece aceit√°vel
- **CRITICAL TRANSIENT DIRECTION PHYSICS**: Beta e tau t√™m comportamentos OPOSTOS para acelera√ß√£o vs desacelera√ß√£o:
  - **ACELERA√á√ÉO (transiente positivo)**: Mais combust√≠vel bate nas paredes, precisa mais beta; Combust√≠vel se acumula nas paredes
  - **DESACELERA√á√ÉO (transiente negativo)**: Menos combust√≠vel bate nas paredes; Combust√≠vel existente evapora das paredes para o fluxo de ar
  - **Beta em acelera√ß√£o**: Lambda lean ‚Üí aumentar beta; Lambda rich ‚Üí diminuir beta
  - **Beta em desacelera√ß√£o**: Lambda lean ‚Üí diminuir beta; Lambda rich ‚Üí aumentar beta (f√≠sica invertida)
  - **Tau em acelera√ß√£o**: Slope positivo (lean crescente) ‚Üí tau baixo, aumentar tau; Slope negativo (rich crescente) ‚Üí tau alto, diminuir tau
  - **Tau em desacelera√ß√£o**: Slope positivo (lean crescente) ‚Üí tau alto, diminuir tau; Slope negativo (rich crescente) ‚Üí tau baixo, aumentar tau (f√≠sica invertida)
  - **Implementa√ß√£o**: Verificar `isPositiveTransient` vs `isNegativeTransient` para aplicar f√≠sica correta
- **CRITICAL WALL WETTING TABLE SIZES**: As tabelas de corre√ß√£o do wall wetting usam tamanhos espec√≠ficos:
  - **wwCorrectionMapBins[WWAE_CORRECTION_SIZE]** - 8 elementos (MAP bins)
  - **wwCorrectionRpmBins[WWAE_CORRECTION_SIZE]** - 8 elementos (RPM bins)
  - **wwBetaCorrection[WWAE_CORRECTION_SIZE][WWAE_CORRECTION_SIZE]** - 8x8 tabela
  - **wwTauCorrection[WWAE_CORRECTION_SIZE][WWAE_CORRECTION_SIZE]** - 8x8 tabela
  - **ERRO COMUM**: Usar WWAE_TABLE_SIZE ou WWAE_RPM_SIZE em vez de WWAE_CORRECTION_SIZE para as tabelas de corre√ß√£o
  - **CORRE√á√ÉO**: Sempre usar WWAE_CORRECTION_SIZE (8) para findIndexMsg() nas tabelas de corre√ß√£o adaptativa
- **CRITICAL TABLE INDEX MAPPING**: Para mapeamento de √≠ndices em tabelas, usar priv::getBin() em vez de findIndexMsg():
  - **Padr√£o correto**: `auto binMap = priv::getBin(map, config->wwCorrectionMapBins); int mapIdx = binMap.Idx;`
  - **Padr√£o incorreto**: `int mapIdx = findIndexMsg("wwMapBins", config->wwCorrectionMapBins, WWAE_CORRECTION_SIZE, map);`
  - **Vantagens**: priv::getBin() √© mais eficiente, elegante, e retorna tanto √≠ndice quanto fra√ß√£o para interpola√ß√£o
  - **Implementa√ß√£o**: Seguir o mesmo padr√£o usado pelo LTFT (Long Term Fuel Trim) na firmware
- **CRITICAL MISSING METHODS**: M√©todos chamados por outros m√≥dulos devem estar declarados no header e implementados:
  - **onActualFuelInjection()**: M√©todo chamado por main_trigger_callback.cpp para notificar inje√ß√µes reais
  - **Declara√ß√£o**: `void onActualFuelInjection(float injectedMass, int cylinderIndex = 0);` no header
  - **Interface**: Deve ser adicionado √† interface `IWallFuelController` como m√©todo virtual puro
  - **Implementa√ß√£o**: Fun√ß√£o b√°sica que verifica condi√ß√µes e registra inje√ß√£o para debug
  - **Override**: Usar `override` na implementa√ß√£o para indicar que sobrescreve m√©todo da interface
  - **Integra√ß√£o**: Permite que o sistema de wall wetting seja notificado de inje√ß√µes reais
- **CRITICAL TAU LEARNING THRESHOLD**: O threshold para detec√ß√£o de transientes ativos na fase prolongada deve ser baixo:
  - **Problema**: Threshold de 50.0f kPa/s impedia transi√ß√£o para fase prolongada (tau learning)
  - **Corre√ß√£o**: Reduzir para 10.0f kPa/s ou adicionar condi√ß√£o de dura√ß√£o m√≠nima
  - **Raz√£o**: Ap√≥s 200ms, derivada de carga diminui mas efeitos de tau ainda s√£o detect√°veis no lambda
  - **Implementa√ß√£o**: `if (transientMagnitude > 10.0f || transientDuration < 1.0f)` para prolonged phase
  - **Debug**: Adicionar logging detalhado para verificar transi√ß√µes entre fases
  - **Resultado**: Permite que mais transientes completem ambas as fases (beta + tau)
- **CRITICAL CROSS-COUPLING CORRECTION**: Implementa√ß√£o de corre√ß√£o de acoplamento entre beta e tau para reduzir instabilidade:
  - **Problema**: Corre√ß√µes simult√¢neas de beta e tau podem causar oscila√ß√µes e instabilidade no sistema
  - **Solu√ß√£o**: Cross-coupling factor que reduz magnitude das corre√ß√µes quando ambos par√¢metros est√£o sendo corrigidos
  - **Implementa√ß√£o**: `float cross_coupling = 1.0f - (0.2f * fabsf(betaCorrection - tauCorrection));`
  - **Aplica√ß√£o**: `betaCorrection = 1.0f + (betaCorrection - 1.0f) * cross_coupling;`
  - **Bounds**: Fator limitado entre 0.5 e 1.0 para evitar over-damping
  - **F√≠sica**: Quando beta e tau divergem muito, reduz ambas as corre√ß√µes para estabilidade
  - **Localiza√ß√£o**: Aplicado no in√≠cio de `applyCorrectionToTable()` antes das corre√ß√µes serem aplicadas √†s tabelas
  - **Resultado**: Sistema mais est√°vel com converg√™ncia mais suave, especialmente durante transientes complexos
- **CRITICAL FINAL CONDITIONS CAPTURE**: A captura das condi√ß√µes finais para corre√ß√£o de tau deve ser feita durante a fase prolongada, N√ÉO quando o transiente termina:
  - **PROBLEMA CR√çTICO**: Condi√ß√µes finais eram capturadas quando transientMagnitude ca√≠a (fim do transiente), mas isso √© fisicamente incorreto
  - **F√çSICA CORRETA**: Tau deve ser corrigido nas condi√ß√µes onde os efeitos prolongados s√£o OBSERVADOS, n√£o onde o transiente para
  - **TIMING INCORRETO**: Capturar no fim do transiente ignora que tau atua durante toda a fase prolongada (200ms-3s)
  - **SOLU√á√ÉO IMPLEMENTADA**: Capturar finalTransientRpm/Map continuamente DURANTE a fase prolongada em updateLambdaResponse()
  - **IMPLEMENTA√á√ÉO**: `m_adaptiveData.finalTransientRpm = rpm; m_adaptiveData.finalTransientMap = map;` dentro do loop da fase prolongada
  - **FALLBACK**: Se condi√ß√µes finais n√£o foram capturadas, usar condi√ß√µes atuais como fallback antes de aplicar corre√ß√µes
  - **RESULTADO**: Tau √© corrigido nas condi√ß√µes corretas onde seus efeitos s√£o realmente observados no lambda
  - **LOCALIZA√á√ÉO**: Removida captura autom√°tica em detectTransients(), adicionada captura cont√≠nua em updateLambdaResponse()
- **CRITICAL CONFIGURABLE LEARNING RATES**: Usar par√¢metros configur√°veis para taxas de aprendizado em vez de valores fixos no c√≥digo:
  - **PROBLEMA**: Taxas de corre√ß√£o fixas (0.10f) no c√≥digo n√£o permitem ajuste fino sem recompila√ß√£o
  - **SOLU√á√ÉO**: Usar `engineConfiguration->wwBetaLearningRate` e `engineConfiguration->wwTauLearningRate`
  - **IMPLEMENTA√á√ÉO BETA**: `const float correctionRate = engineConfiguration->wwBetaLearningRate;` em calculateBetaCorrection()
  - **IMPLEMENTA√á√ÉO TAU**: `const float correctionRate = engineConfiguration->wwTauLearningRate;` em calculateTauCorrection()
  - **VANTAGENS**: Permite ajuste fino via TunerStudio sem recompila√ß√£o, diferentes taxas para beta vs tau
  - **FLEXIBILIDADE**: Usu√°rio pode ajustar agressividade do aprendizado baseado no comportamento do motor
  - **TUNING**: Taxa baixa (0.05) para motores est√°veis, taxa alta (0.15) para aprendizado r√°pido
  - **RESULTADO**: Sistema mais flex√≠vel e tun√°vel para diferentes aplica√ß√µes e prefer√™ncias do usu√°rio
- **CRITICAL LTIT PHASE VERIFICATION**: LTIT deve verificar se est√° realmente na fase de marcha lenta antes de aprender:
  - **PROBLEMA**: LTIT estava aprendendo em qualquer fase (Coasting, Running, etc.) desde que RPM estivesse pr√≥ximo do target
  - **CORRE√á√ÉO**: Verificar `idleController.getCurrentPhase() == IIdleController::Phase::Idling` antes de aprender
  - **IMPLEMENTA√á√ÉO**: Adicionado getter p√∫blico `getCurrentPhase()` no IdleController para acesso seguro
  - **RESULTADO**: LTIT s√≥ aprende durante marcha lenta real, n√£o durante coast-down ou outras condi√ß√µes
- **CRITICAL LTIT INTEGRATOR THRESHOLD**: Corre√ß√£o da l√≥gica do threshold do integrador PID:
  - **PROBLEMA**: L√≥gica invertida - LTIT aprendia quando integrador era MENOR que threshold
  - **F√çSICA CORRETA**: Integrador alto indica erro persistente que precisa ser corrigido pelo LTIT
  - **CORRE√á√ÉO**: `if (fabsf(idleIntegral) < minThreshold) return false;` - s√≥ aprende se integrador for MAIOR que threshold
  - **RAZ√ÉO**: Integrador baixo significa PID n√£o est√° trabalhando, n√£o h√° necessidade de corre√ß√£o LTIT
  - **RESULTADO**: LTIT s√≥ aprende quando h√° realmente erro persistente que justifica corre√ß√£o da tabela
- **CRITICAL LTIT CLOSED LOOP VERIFICATION**: LTIT deve verificar se PID est√° realmente ativo:
  - **PROBLEMA**: LTIT poderia tentar aprender mesmo em open loop onde integrador n√£o √© v√°lido
  - **CORRE√á√ÉO**: Verificar `idleController.useClosedLoop` antes de usar valor do integrador
  - **IMPLEMENTA√á√ÉO**: Adicionada verifica√ß√£o ap√≥s valida√ß√£o da fase de marcha lenta
  - **RESULTADO**: LTIT s√≥ aprende quando PID est√° realmente controlando, garantindo integrador v√°lido

# Scratchpad

## AN√ÅLISE CR√çTICA: PROBLEMA TAU WALL WETTING ADAPTATIVO ‚ö†Ô∏è

### PROBLEMA REPORTADO PELO USU√ÅRIO ‚ö†Ô∏è
**Sintoma**: "Tau est√° sendo corrigido nas c√©lulas erradas, ou apenas corrigido em situa√ß√µes de desacelera√ß√£o"

### AN√ÅLISE DETALHADA DO C√ìDIGO ATUAL üîç

#### 1. L√ìGICA DE DETEC√á√ÉO DE TRANSIENTES ‚úÖ CORRETA
**Localiza√ß√£o**: `detectTransients()` (linha 294-370)
- **CORRETO**: Ambos transientes (positivos e negativos) iniciam `startImmediatePhase()`
- **CORRETO**: Threshold √∫nico de 30 kPa/s para ambos os tipos
- **CORRETO**: Captura condi√ß√µes iniciais para beta em ambos os casos
- **CORRETO**: Reset de condi√ß√µes finais para captura posterior

#### 2. SEQU√äNCIA DE FASES ‚úÖ CORRETA
**Localiza√ß√£o**: `updateLambdaResponse()` (linha 854-950)
- **CORRETO**: Fase imediata (0-200ms) ‚Üí automaticamente inicia fase prolongada
- **CORRETO**: Fase prolongada (din√¢mica baseada em 3√ótau)
- **CORRETO**: Captura cont√≠nua de condi√ß√µes finais durante fase prolongada

#### 3. PER√çODOS DE ADAPTA√á√ÉO SEPARADOS ‚ö†Ô∏è POSS√çVEL CAUSA
**Localiza√ß√£o**: `updateAdaptationMode()` (linha 950-986)
- **PROBLEMA IDENTIFICADO**: Sistema alterna entre ADAPT_BETA_ONLY e ADAPT_TAU_ONLY
- **Configura√ß√£o atual**: 6 transientes beta ‚Üí 6 transientes tau ‚Üí repete
- **POSS√çVEL BIAS**: Se padr√£o de condu√ß√£o tem mais acelera√ß√µes que desacelera√ß√µes, pode parecer que tau s√≥ aprende em desacelera√ß√µes

#### 4. APLICA√á√ÉO DE CORRE√á√ïES ‚úÖ CORRETA
**Localiza√ß√£o**: `applyCorrectionToTable()` (linha 664-754)
- **CORRETO**: Beta aplicado nas condi√ß√µes iniciais (`initialTransientRpm/Map`)
- **CORRETO**: Tau aplicado nas condi√ß√µes finais (`finalTransientRpm/Map`)
- **CORRETO**: Verifica√ß√µes de NaN e bounds

#### 5. C√ÅLCULO DE TAU ‚úÖ CORRETA
**Localiza√ß√£o**: `calculateTauCorrection()` (linha 570-660)
- **CORRETO**: An√°lise de regress√£o linear (slope) em vez de m√©dia
- **CORRETO**: F√≠sica diferente para acelera√ß√£o vs desacelera√ß√£o
- **CORRETO**: Thresholds e prote√ß√µes adequadas

### POSS√çVEIS CAUSAS DO PROBLEMA ‚ö†Ô∏è

#### CAUSA 1: BIAS DOS PER√çODOS DE ADAPTA√á√ÉO ‚ö†Ô∏è
**Problema**: Sistema pode estar em per√≠odo ADAPT_BETA_ONLY durante acelera√ß√µes e ADAPT_TAU_ONLY durante desacelera√ß√µes
**Evid√™ncia**: 
- Per√≠odos fixos de 6 transientes cada
- Se padr√£o de condu√ß√£o tem mais acelera√ß√µes que desacelera√ß√µes, tau n√£o aprende nelas
- Se padr√£o tem mais desacelera√ß√µes seguidas, beta n√£o aprende nelas

#### CAUSA 2: THRESHOLD DE DETEC√á√ÉO UNIFORME ‚ö†Ô∏è
**Problema**: Threshold de 30 kPa/s pode ser inadequado para desacelera√ß√µes
**Evid√™ncia**:
- Desacelera√ß√µes podem ter magnitude menor que acelera√ß√µes
- Threshold √∫nico pode favorecer detec√ß√£o de acelera√ß√µes
- Resultado: Mais transientes de acelera√ß√£o detectados

#### CAUSA 3: TIMEOUT E INTERRUP√á√ïES ‚ö†Ô∏è
**Problema**: Transientes sobrepostos podem interromper fase prolongada
**Evid√™ncia**:
- Threshold de 50 kPa/s para detec√ß√£o de interrup√ß√£o
- `applyIncompleteTransientCorrection()` s√≥ aplica beta
- Se acelera√ß√µes s√£o mais "agressivas", tau nunca completa

#### CAUSA 4: DURA√á√ÉO DIN√ÇMICA DA FASE PROLONGADA ‚ö†Ô∏è
**Problema**: Dura√ß√£o baseada em tau pode ser inadequada
**Evid√™ncia**:
- Dura√ß√£o = 3√ótau pode ser muito longa para alguns casos
- Timeout de 5s pode ser insuficiente para tau alto
- Fase prolongada pode n√£o completar adequadamente

### DIAGN√ìSTICO NECESS√ÅRIO üîß

#### LOGGING DETALHADO REQUERIDO:
1. **Contadores por tipo de transiente**: Quantos positivos vs negativos detectados
2. **Per√≠odos de adapta√ß√£o**: Quando est√° em BETA_ONLY vs TAU_ONLY
3. **Fases completadas**: Quantas fases prolongadas completam vs interrompem
4. **Corre√ß√µes aplicadas**: Quando beta vs tau s√£o realmente aplicados
5. **Condi√ß√µes de aplica√ß√£o**: RPM/MAP onde corre√ß√µes s√£o aplicadas

#### TESTES PROPOSTOS:
1. **For√ßar ADAPT_BOTH**: Temporariamente permitir ambos beta e tau sempre
2. **Threshold adaptativo**: Diferentes thresholds para acelera√ß√£o vs desacelera√ß√£o
3. **Timeout din√¢mico**: Baseado no tau atual em vez de fixo
4. **Estat√≠sticas detalhadas**: Contadores de sucesso/falha por tipo

### CORRE√á√ïES PROPOSTAS üõ†Ô∏è

#### CORRE√á√ÉO 1: THRESHOLD ADAPTATIVO ‚úÖ
```cpp
const float accelThreshold = 30.0f;  // Acelera√ß√£o: threshold normal
const float decelThreshold = 20.0f;  // Desacelera√ß√£o: threshold menor
```

#### CORRE√á√ÉO 2: TIMEOUT DIN√ÇMICO ‚úÖ
```cpp
float dynamicTimeout = fmaxf(5.0f, m_adaptiveData.currentTau * 4.0f);
```

#### CORRE√á√ÉO 3: MODO ADAPT_BOTH TEMPOR√ÅRIO ‚úÖ
```cpp
// Para diagn√≥stico, for√ßar adapta√ß√£o de ambos
m_adaptiveData.currentAdaptationMode = WwAdaptiveData::ADAPT_BOTH;
```

#### CORRE√á√ÉO 4: LOGGING DETALHADO ‚úÖ
```cpp
efiPrintf("WW: Transient %s, mode=%s, phase=%s", 
    isPositive ? "ACCEL" : "DECEL",
    getCurrentAdaptationModeString(),
    getCurrentPhaseString());
```

### PLANO DE A√á√ÉO IMEDIATO üìã

[ ] **PASSO 1**: Implementar logging detalhado para diagn√≥stico
[ ] **PASSO 2**: Coletar dados de campo sobre padr√µes de transientes
[ ] **PASSO 3**: Implementar threshold adaptativo
[ ] **PASSO 4**: Implementar timeout din√¢mico
[ ] **PASSO 5**: Testar modo ADAPT_BOTH temporariamente
[ ] **PASSO 6**: Ajustar per√≠odos de adapta√ß√£o baseado nos dados

### CONCLUS√ÉO PRELIMINAR üìä

**MAIS PROV√ÅVEL**: O problema n√£o est√° na l√≥gica fundamental, mas sim nos **per√≠odos de adapta√ß√£o separados** que podem criar um bias aparente baseado no padr√£o de condu√ß√£o do usu√°rio.

**SOLU√á√ÉO IMEDIATA**: Implementar logging detalhado para confirmar a hip√≥tese e depois ajustar os per√≠odos ou implementar threshold adaptativo.

**F√çSICA EST√Å CORRETA**: A implementa√ß√£o segue corretamente a f√≠sica do wall wetting, o problema parece ser de timing/scheduling das corre√ß√µes.

## PROBLEMAS CR√çTICOS IDENTIFICADOS NA L√ìGICA ATUAL ‚ö†Ô∏è