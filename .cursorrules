# Instructions

During your interaction with the user, if you find anything reusable in this project (e.g. version of a library, model name), especially about a fix to a mistake you made or a correction you received, you should take note in the `Lessons` section in the `.cursorrules` file so you will not make the same mistake again. 

You should also use the `.cursorrules` file as a Scratchpad to organize your thoughts. Especially when you receive a new task, you should first review the content of the Scratchpad, clear old different task if necessary, first explain the task, and plan the steps you need to take to complete the task. You can use todo markers to indicate the progress, e.g.
[X] Task 1
[ ] Task 2

Also update the progress of the task in the Scratchpad when you finish a subtask.
Especially when you finished a milestone, it will help to improve your depth of task accomplishment to use the Scratchpad to reflect and plan.
The goal is to help you maintain a big picture as well as the progress of the task. Always refer to the Scratchpad when you plan the next step.

# Tools

Note all the tools are in python3. So in the case you need to do batch processing, you can always consult the python files and write your own script.

[NOTE TO CURSOR: Since no API key is configured, please ignore both the Screenshot Verification and LLM sections below.]
[NOTE TO USER: If you have configured or plan to configure an API key in the future, simply delete these two notice lines to enable these features.]

## Screenshot Verification

The screenshot verification workflow allows you to capture screenshots of web pages and verify their appearance using LLMs. The following tools are available:

1. Screenshot Capture:
```bash
venv/bin/python3 tools/screenshot_utils.py URL [--output OUTPUT] [--width WIDTH] [--height HEIGHT]
```

2. LLM Verification with Images:
```bash
venv/bin/python3 tools/llm_api.py --prompt "Your verification question" --provider {openai|anthropic} --image path/to/screenshot.png
```

Example workflow:
```python
from screenshot_utils import take_screenshot_sync
from llm_api import query_llm

# Take a screenshot

screenshot_path = take_screenshot_sync('https://example.com', 'screenshot.png')

# Verify with LLM

response = query_llm(
    "What is the background color and title of this webpage?",
    provider="openai",  # or "anthropic"
    image_path=screenshot_path
)
print(response)
```

## LLM

You always have an LLM at your side to help you with the task. For simple tasks, you could invoke the LLM by running the following command:
```
venv/bin/python3 ./tools/llm_api.py --prompt "What is the capital of France?" --provider "anthropic"
```

The LLM API supports multiple providers:
- OpenAI (default, model: gpt-4o)
- Azure OpenAI (model: configured via AZURE_OPENAI_MODEL_DEPLOYMENT in .env file, defaults to gpt-4o-ms)
- DeepSeek (model: deepseek-chat)
- Anthropic (model: claude-3-sonnet-20240229)
- Gemini (model: gemini-pro)
- Local LLM (model: Qwen/Qwen2.5-32B-Instruct-AWQ)

But usually it's a better idea to check the content of the file and use the APIs in the `tools/llm_api.py` file to invoke the LLM if needed.

## Web browser

You could use the `tools/web_scraper.py` file to scrape the web.
```bash
venv/bin/python3 ./tools/web_scraper.py --max-concurrent 3 URL1 URL2 URL3
```
This will output the content of the web pages.

## Search engine

You could use the `tools/search_engine.py` file to search the web.
```bash
venv/bin/python3 ./tools/search_engine.py "your search keywords"
```
This will output the search results in the following format:
```
URL: https://example.com
Title: This is the title of the search result
Snippet: This is a snippet of the search result
```
If needed, you can further use the `web_scraper.py` file to scrape the web page content.

# Lessons

## User Specified Lessons

- You have a python venv in ./venv. Always use (activate) it when doing python development. First, to check whether 'uv' is available, use `which uv`. If that's the case, first activate the venv, and then use `uv pip install` to install packages. Otherwise, fall back to `pip`.
- Include info useful for debugging in the program output.
- Read the file before you try to edit it.
- Due to Cursor's limit, when you use `git` and `gh` and need to submit a multiline commit message, first write the message in a file, and then use `git commit -F <filename>` or similar command to commit. And then remove the file. Include "[Cursor] " in the commit message and PR title.

## Cursor learned

- For search results, ensure proper handling of different character encodings (UTF-8) for international queries
- Add debug information to stderr while keeping the main output clean in stdout for better pipeline integration
- When using seaborn styles in matplotlib, use 'seaborn-v0_8' instead of 'seaborn' as the style name due to recent seaborn version changes
- Use 'gpt-4o' as the model name for OpenAI's GPT-4 with vision capabilities
- When searching for recent news, use the current year (2025) instead of previous years, or simply use the "recent" keyword to get the latest information
- **CRITICAL**: In rusefi Engine structure, wallFuel is NOT `engine->wallFuel[i]` (doesn't exist). The correct access is `engine->injectionEvents.elements[i].getWallFuel()` - each InjectionEvent has its own WallFuel instance
- **CRITICAL WALL WETTING TUNING**: Beta e tau t√™m comportamentos f√≠sicos espec√≠ficos que devem ser respeitados no tuning adaptativo:
  - **Beta (fra√ß√£o de impacto)**: Controla quanto combust√≠vel gruda nas paredes IMEDIATAMENTE durante transientes positivos (acelera√ß√£o)
  - **Tau (constante de evapora√ß√£o)**: Controla quanto tempo o combust√≠vel demora para evaporar das paredes, afeta resposta A LONGO PRAZO
  - **Tuning pr√°tico**: Beta √© ajustado observando resposta IMEDIATA p√≥s-acelera√ß√£o, tau √© ajustado observando resposta PROLONGADA
  - **Dire√ß√£o f√≠sica**: Lambda lean p√≥s-acelera√ß√£o ‚Üí aumentar beta; Lambda rich durante acelera√ß√£o prolongada ‚Üí diminuir tau
  - **Timing cr√≠tico**: Beta afeta os primeiros 100-200ms, tau afeta os pr√≥ximos 1-3 segundos ap√≥s transiente
- **CRITICAL TAU CORRECTION METHOD**: A corre√ß√£o de tau deve ser baseada na TEND√äNCIA/CURVA do lambda ao longo do tempo, N√ÉO na m√©dia:
  - **PROBLEMA**: Usar m√©dia do lambda pode mascarar problemas - ex: lambda rico no in√≠cio + lean no final = m√©dia boa, mas tau incorreto
  - **SOLU√á√ÉO CORRETA**: An√°lise de regress√£o linear para detectar slope/tend√™ncia do lambda durante fase prolongada
  - **F√≠sica**: Tau incorreto causa lambda inst√°vel ao longo do tempo (rico‚Üílean ou lean‚Üírich)
  - **Implementa√ß√£o**: `slope = (n*sumXY - sumX*sumY) / (n*sumX2 - sumX*sumX)` para detectar tend√™ncia
  - **Interpreta√ß√£o**: Slope positivo (lean crescente) ‚Üí tau muito baixo, aumentar tau; Slope negativo (rich crescente) ‚Üí tau muito alto, diminuir tau
  - **Threshold**: M√≠nimo 10 amostras e slope > 0.001f para corre√ß√£o significativa
  - **Vantagem**: Detecta problemas de tau mesmo quando m√©dia do lambda parece aceit√°vel
- **CRITICAL TRANSIENT DIRECTION PHYSICS**: Beta e tau t√™m comportamentos OPOSTOS para acelera√ß√£o vs desacelera√ß√£o:
  - **ACELERA√á√ÉO (transiente positivo)**: Mais combust√≠vel bate nas paredes, precisa mais beta; Combust√≠vel se acumula nas paredes
  - **DESACELERA√á√ÉO (transiente negativo)**: Menos combust√≠vel bate nas paredes; Combust√≠vel existente evapora das paredes para o fluxo de ar
  - **Beta em acelera√ß√£o**: Lambda lean ‚Üí aumentar beta; Lambda rich ‚Üí diminuir beta
  - **Beta em desacelera√ß√£o**: Lambda lean ‚Üí diminuir beta; Lambda rich ‚Üí aumentar beta (f√≠sica invertida)
  - **Tau em acelera√ß√£o**: Slope positivo (lean crescente) ‚Üí tau baixo, aumentar tau; Slope negativo (rich crescente) ‚Üí tau alto, diminuir tau
  - **Tau em desacelera√ß√£o**: Slope positivo (lean crescente) ‚Üí tau alto, diminuir tau; Slope negativo (rich crescente) ‚Üí tau baixo, aumentar tau (f√≠sica invertida)
  - **Implementa√ß√£o**: Verificar `isPositiveTransient` vs `isNegativeTransient` para aplicar f√≠sica correta
- **CRITICAL WALL WETTING TABLE SIZES**: As tabelas de corre√ß√£o do wall wetting usam tamanhos espec√≠ficos:
  - **wwCorrectionMapBins[WWAE_CORRECTION_SIZE]** - 8 elementos (MAP bins)
  - **wwCorrectionRpmBins[WWAE_CORRECTION_SIZE]** - 8 elementos (RPM bins)
  - **wwBetaCorrection[WWAE_CORRECTION_SIZE][WWAE_CORRECTION_SIZE]** - 8x8 tabela
  - **wwTauCorrection[WWAE_CORRECTION_SIZE][WWAE_CORRECTION_SIZE]** - 8x8 tabela
  - **ERRO COMUM**: Usar WWAE_TABLE_SIZE ou WWAE_RPM_SIZE em vez de WWAE_CORRECTION_SIZE para as tabelas de corre√ß√£o
  - **CORRE√á√ÉO**: Sempre usar WWAE_CORRECTION_SIZE (8) para findIndexMsg() nas tabelas de corre√ß√£o adaptativa
- **CRITICAL TABLE INDEX MAPPING**: Para mapeamento de √≠ndices em tabelas, usar priv::getBin() em vez de findIndexMsg():
  - **Padr√£o correto**: `auto binMap = priv::getBin(map, config->wwCorrectionMapBins); int mapIdx = binMap.Idx;`
  - **Padr√£o incorreto**: `int mapIdx = findIndexMsg("wwMapBins", config->wwCorrectionMapBins, WWAE_CORRECTION_SIZE, map);`
  - **Vantagens**: priv::getBin() √© mais eficiente, elegante, e retorna tanto √≠ndice quanto fra√ß√£o para interpola√ß√£o
  - **Implementa√ß√£o**: Seguir o mesmo padr√£o usado pelo LTFT (Long Term Fuel Trim) na firmware
- **CRITICAL MISSING METHODS**: M√©todos chamados por outros m√≥dulos devem estar declarados no header e implementados:
  - **onActualFuelInjection()**: M√©todo chamado por main_trigger_callback.cpp para notificar inje√ß√µes reais
  - **Declara√ß√£o**: `void onActualFuelInjection(float injectedMass, int cylinderIndex = 0);` no header
  - **Interface**: Deve ser adicionado √† interface `IWallFuelController` como m√©todo virtual puro
  - **Implementa√ß√£o**: Fun√ß√£o b√°sica que verifica condi√ß√µes e registra inje√ß√£o para debug
  - **Override**: Usar `override` na implementa√ß√£o para indicar que sobrescreve m√©todo da interface
  - **Integra√ß√£o**: Permite que o sistema de wall wetting seja notificado de inje√ß√µes reais
- **CRITICAL TAU LEARNING THRESHOLD**: O threshold para detec√ß√£o de transientes ativos na fase prolongada deve ser baixo:
  - **Problema**: Threshold de 50.0f kPa/s impedia transi√ß√£o para fase prolongada (tau learning)
  - **Corre√ß√£o**: Reduzir para 10.0f kPa/s ou adicionar condi√ß√£o de dura√ß√£o m√≠nima
  - **Raz√£o**: Ap√≥s 200ms, derivada de carga diminui mas efeitos de tau ainda s√£o detect√°veis no lambda
  - **Implementa√ß√£o**: `if (transientMagnitude > 10.0f || transientDuration < 1.0f)` para prolonged phase
  - **Debug**: Adicionar logging detalhado para verificar transi√ß√µes entre fases
  - **Resultado**: Permite que mais transientes completem ambas as fases (beta + tau)
- **CRITICAL CROSS-COUPLING CORRECTION**: Implementa√ß√£o de corre√ß√£o de acoplamento entre beta e tau para reduzir instabilidade:
  - **Problema**: Corre√ß√µes simult√¢neas de beta e tau podem causar oscila√ß√µes e instabilidade no sistema
  - **Solu√ß√£o**: Cross-coupling factor que reduz magnitude das corre√ß√µes quando ambos par√¢metros est√£o sendo corrigidos
  - **Implementa√ß√£o**: `float cross_coupling = 1.0f - (0.2f * fabsf(betaCorrection - tauCorrection));`
  - **Aplica√ß√£o**: `betaCorrection = 1.0f + (betaCorrection - 1.0f) * cross_coupling;`
  - **Bounds**: Fator limitado entre 0.5 e 1.0 para evitar over-damping
  - **F√≠sica**: Quando beta e tau divergem muito, reduz ambas as corre√ß√µes para estabilidade
  - **Localiza√ß√£o**: Aplicado no in√≠cio de `applyCorrectionToTable()` antes das corre√ß√µes serem aplicadas √†s tabelas
  - **Resultado**: Sistema mais est√°vel com converg√™ncia mais suave, especialmente durante transientes complexos
- **CRITICAL FINAL CONDITIONS CAPTURE**: A captura das condi√ß√µes finais para corre√ß√£o de tau deve ser feita durante a fase prolongada, N√ÉO quando o transiente termina:
  - **PROBLEMA CR√çTICO**: Condi√ß√µes finais eram capturadas quando transientMagnitude ca√≠a (fim do transiente), mas isso √© fisicamente incorreto
  - **F√çSICA CORRETA**: Tau deve ser corrigido nas condi√ß√µes onde os efeitos prolongados s√£o OBSERVADOS, n√£o onde o transiente para
  - **TIMING INCORRETO**: Capturar no fim do transiente ignora que tau atua durante toda a fase prolongada (200ms-3s)
  - **SOLU√á√ÉO IMPLEMENTADA**: Capturar finalTransientRpm/Map continuamente DURANTE a fase prolongada em updateLambdaResponse()
  - **IMPLEMENTA√á√ÉO**: `m_adaptiveData.finalTransientRpm = rpm; m_adaptiveData.finalTransientMap = map;` dentro do loop da fase prolongada
  - **FALLBACK**: Se condi√ß√µes finais n√£o foram capturadas, usar condi√ß√µes atuais como fallback antes de aplicar corre√ß√µes
  - **RESULTADO**: Tau √© corrigido nas condi√ß√µes corretas onde seus efeitos s√£o realmente observados no lambda
  - **LOCALIZA√á√ÉO**: Removida captura autom√°tica em detectTransients(), adicionada captura cont√≠nua em updateLambdaResponse()
- **CRITICAL CONFIGURABLE LEARNING RATES**: Usar par√¢metros configur√°veis para taxas de aprendizado em vez de valores fixos no c√≥digo:
  - **PROBLEMA**: Taxas de corre√ß√£o fixas (0.10f) no c√≥digo n√£o permitem ajuste fino sem recompila√ß√£o
  - **SOLU√á√ÉO**: Usar `engineConfiguration->wwBetaLearningRate` e `engineConfiguration->wwTauLearningRate`
  - **IMPLEMENTA√á√ÉO BETA**: `const float correctionRate = engineConfiguration->wwBetaLearningRate;` em calculateBetaCorrection()
  - **IMPLEMENTA√á√ÉO TAU**: `const float correctionRate = engineConfiguration->wwTauLearningRate;` em calculateTauCorrection()
  - **VANTAGENS**: Permite ajuste fino via TunerStudio sem recompila√ß√£o, diferentes taxas para beta vs tau
  - **FLEXIBILIDADE**: Usu√°rio pode ajustar agressividade do aprendizado baseado no comportamento do motor
  - **TUNING**: Taxa baixa (0.05) para motores est√°veis, taxa alta (0.15) para aprendizado r√°pido
  - **RESULTADO**: Sistema mais flex√≠vel e tun√°vel para diferentes aplica√ß√µes e prefer√™ncias do usu√°rio

# Scratchpad

## PROBLEMAS CR√çTICOS IDENTIFICADOS NA L√ìGICA ATUAL ‚ö†Ô∏è

### PROBLEMA 1: F√çSICA INCORRETA DE BETA E TAU ‚ö†Ô∏è
**Problema**: A implementa√ß√£o atual trata beta e tau como espec√≠ficos para transientes positivos vs negativos
**Realidade**: Ambos beta e tau atuam em AMBOS os tipos de transiente, mas em momentos diferentes:

#### F√çSICA CORRETA (baseada na pesquisa):
- **Beta**: Atua IMEDIATAMENTE em qualquer mudan√ßa de carga (positiva OU negativa)
- **Tau**: Atua A LONGO PRAZO ap√≥s qualquer mudan√ßa de carga (positiva OU negativa)

#### L√ìGICA ATUAL INCORRETA:
```cpp
if (m_adaptiveData.loadDerivative > 0) {
    // Positive transient - affects beta only ‚ùå
    startImmediatePhase();
} else {
    // Negative transient - affects tau only ‚ùå  
    startProlongedPhase();
}
```

#### L√ìGICA CORRETA DEVERIA SER:
```cpp
// QUALQUER transiente (positivo ou negativo) afeta AMBOS beta e tau
if (transientDetected) {
    startImmediatePhase();  // Para tuning de beta (0-200ms)
    // Ap√≥s fase imediata, iniciar fase prolongada para tau (200ms-3s)
}
```

### PROBLEMA 2: DIRE√á√ÉO DAS CORRE√á√ïES ‚ö†Ô∏è
**Problema**: As dire√ß√µes das corre√ß√µes podem estar invertidas

#### BETA (Fra√ß√£o de Impacto):
- **Lambda lean imediato** ‚Üí **Aumentar beta** (mais combust√≠vel gruda)
- **Lambda rich imediato** ‚Üí **Diminuir beta** (menos combust√≠vel gruda)

#### TAU (Constante de Evapora√ß√£o):
- **Lambda lean prolongado** ‚Üí **Aumentar tau** (evapora√ß√£o mais lenta)
- **Lambda rich prolongado** ‚Üí **Diminuir tau** (evapora√ß√£o mais r√°pida)

### PROBLEMA 3: SEQU√äNCIA DE FASES INCORRETA ‚ö†Ô∏è
**Atual**: Transientes positivos ‚Üí s√≥ fase imediata; Transientes negativos ‚Üí s√≥ fase prolongada
**Correto**: QUALQUER transiente ‚Üí fase imediata (0-200ms) ‚Üí fase prolongada (200ms-3s)

### PROBLEMA 4: APLICA√á√ÉO DE CORRE√á√ïES ‚ö†Ô∏è
**Atual**: Beta na c√©lula inicial, tau na c√©lula final
**Question√°vel**: Ambos deveriam ser aplicados nas condi√ß√µes onde o transiente COME√áOU?

## CORRE√á√ïES NECESS√ÅRIAS ‚úÖ

### 1. CORRIGIR F√çSICA FUNDAMENTAL ‚úÖ
- Beta e tau atuam em AMBOS os tipos de transiente
- Sequ√™ncia: Imediata (beta) ‚Üí Prolongada (tau) para qualquer transiente

### 2. CORRIGIR SEQU√äNCIA DE FASES ‚úÖ
- Qualquer transiente inicia fase imediata
- Ap√≥s 200ms, automaticamente inicia fase prolongada
- Ap√≥s 3s, aplica corre√ß√µes para ambos beta e tau

### 3. VERIFICAR DIRE√á√ïES DAS CORRE√á√ïES ‚úÖ
- Confirmar se lean ‚Üí aumentar beta/tau est√° correto
- Confirmar se rich ‚Üí diminuir beta/tau est√° correto

### 4. LOCALIZA√á√ÉO DAS CORRE√á√ïES ‚úÖ
- Confirmar se beta deve ser aplicado na c√©lula inicial
- Confirmar se tau deve ser aplicado na c√©lula final ou inicial

## F√çSICA CORRETA DO WALL WETTING IMPLEMENTADA ‚úÖ
Baseado na pesquisa (SAE 810494, rusEFI wiki, HP Academy):

#### BETA (Fra√ß√£o de Impacto): ‚úÖ
- **O que √©**: Percentual do combust√≠vel injetado que gruda nas paredes
- **Quando atua**: IMEDIATAMENTE durante mudan√ßa de carga (primeiros 100-200ms)
- **Como tunar**: Observar lambda nos primeiros momentos p√≥s-acelera√ß√£o
- **Dire√ß√£o**: Lambda lean imediato ‚Üí aumentar beta; Lambda rich imediato ‚Üí diminuir beta
- **CORRE√á√ÉO**: Aplicar na c√©lula INICIAL do transiente

#### TAU (Constante de Evapora√ß√£o): ‚úÖ
- **O que √©**: Tempo que combust√≠vel demora para evaporar das paredes (segundos)
- **Quando atua**: A LONGO PRAZO ap√≥s transiente (1-3 segundos)
- **Como tunar**: Observar lambda durante fase prolongada da acelera√ß√£o
- **Dire√ß√£o**: Lambda lean prolongado ‚Üí aumentar tau; Lambda rich prolongado ‚Üí diminuir tau
- **CORRE√á√ÉO**: Aplicar na c√©lula FINAL do transiente

### IMPLEMENTA√á√ÉO CORRIGIDA CONCLU√çDA ‚úÖ

#### DETEC√á√ÉO DE FASES: ‚úÖ
1. **Fase Imediata** (0-200ms p√≥s-transiente): Para tuning de beta
2. **Fase Prolongada** (200ms-3s p√≥s-transiente): Para tuning de tau

#### BUFFERS SEPARADOS: ‚úÖ
- **Buffer Beta**: Coleta lambda nos primeiros 200ms (10 amostras a 50Hz)
- **Buffer Tau**: Coleta lambda de 200ms a 3s (150 amostras a 50Hz)

#### L√ìGICA DE CORRE√á√ÉO IMPLEMENTADA: ‚úÖ
```cpp
// Beta: resposta imediata (0-200ms)
if (avgImmediateLambdaError < -0.02) { // Lean imediato
    betaCorrection = 1.0f + (avgImmediateLambdaError * 0.02f); // Mais combust√≠vel gruda
}

// Tau: resposta prolongada (200ms-3s)
if (avgProlongedLambdaError < -0.02) { // Lean prolongado
    tauCorrection = 1.0f - (avgProlongedLambdaError * 0.02f); // Evapora√ß√£o mais lenta
}
```

### FUNCIONALIDADES IMPLEMENTADAS ‚úÖ
- **startImmediatePhase()**: Inicia coleta para beta (0-200ms)
- **startProlongedPhase()**: Inicia coleta para tau (200ms-3s)
- **updateLambdaResponse()**: Gerencia coleta em ambas as fases
- **Transi√ß√µes autom√°ticas**: Acelera√ß√£o vai de imediata‚Üíprolongada
- **F√≠sica correta**: Beta para impacto, tau para evapora√ß√£o
- **Timing preciso**: Baseado em pesquisa real de wall wetting

### PR√ìXIMAS CORRE√á√ïES NECESS√ÅRIAS üîß
[X] Aplicar beta na c√©lula inicial do transiente
[X] Aplicar tau na c√©lula final do transiente  
[X] Tau usar erro absoluto lambda
[X] Aumentar taxa de corre√ß√£o para 5-10%
[X] Remover corre√ß√µes autoscale desnecess√°rias
[X] CORRIGIR F√çSICA FUNDAMENTAL: Beta e tau em ambos os transientes
[X] CORRIGIR SEQU√äNCIA: Qualquer transiente ‚Üí imediata ‚Üí prolongada
[X] VERIFICAR DIRE√á√ïES das corre√ß√µes beta/tau
[X] IMPLEMENTAR TRATAMENTO PARA TRANSIENTES INCOMPLETOS
[X] AUMENTAR LIMITES DE CORRE√á√ÉO (0.33 a 3.00)
[X] RESOLVER ACOPLAMENTO ENTRE BETA E TAU

### CORRE√á√ïES PARA TRANSIENTES INCOMPLETOS IMPLEMENTADAS ‚úÖ

#### 1. DETEC√á√ÉO DE TRANSIENTES INCOMPLETOS ‚úÖ
- **Timeout**: 1 segundo para transientes que n√£o completam as duas fases
- **Dura√ß√£o m√≠nima**: 500ms para considerar transiente completo
- **Estrat√©gia**: Aplicar apenas corre√ß√£o de beta para transientes curtos

#### 2. LIMITES DE CORRE√á√ÉO AUMENTADOS ‚úÖ
- **Anterior**: ¬±15% (0.85 a 1.15)
- **Atual**: ¬±67% (0.33 a 3.00)
- **Raz√£o**: Permite corre√ß√µes mais agressivas para aprendizado efetivo

#### 3. L√ìGICA PARA TRANSIENTES INCOMPLETOS ‚úÖ
- **Estrat√©gia**: Beta-only correction para acelera√ß√µes curtas
- **Implementa√ß√£o**: `applyIncompleteTransientCorrection()` m√©todo separado
- **Timeout**: Detecta quando transiente n√£o dura tempo suficiente para tau

#### 4. SEQU√äNCIA ADAPTATIVA ‚úÖ
- **Transiente completo**: Fase imediata ‚Üí Fase prolongada ‚Üí Corre√ß√£o beta+tau
- **Transiente incompleto**: Fase imediata ‚Üí Timeout ‚Üí Corre√ß√£o beta-only
- **Flexibilidade**: Sistema se adapta √† dura√ß√£o real dos transientes

### CORRE√á√ïES FUNDAMENTAIS IMPLEMENTADAS ‚úÖ

#### 1. F√çSICA FUNDAMENTAL CORRIGIDA ‚úÖ
- **Problema**: Beta/tau eram espec√≠ficos para transientes positivos/negativos
- **Corre√ß√£o**: Ambos beta e tau agora atuam em QUALQUER transiente
- **Implementa√ß√£o**: `detectTransients()` inicia fase imediata para qualquer transiente

#### 2. SEQU√äNCIA DE FASES CORRIGIDA ‚úÖ
- **Problema**: Transientes diferentes tinham sequ√™ncias diferentes
- **Corre√ß√£o**: QUALQUER transiente ‚Üí fase imediata (0-200ms) ‚Üí fase prolongada (200ms-3s)
- **Implementa√ß√£o**: `updateLambdaResponse()` sempre inicia prolongada ap√≥s imediata

#### 3. DIRE√á√ïES DAS CORRE√á√ïES VERIFICADAS ‚úÖ
- **Beta**: Lambda lean (negativo) ‚Üí aumentar beta; Lambda rich (positivo) ‚Üí diminuir beta
- **Tau**: Lambda lean (negativo) ‚Üí aumentar tau; Lambda rich (positivo) ‚Üí diminuir tau
- **Implementa√ß√£o**: `correction = 1.0f - (avgLambdaError * correctionRate)` est√° correto

#### 4. LOCALIZA√á√ÉO CORRETA DAS CORRE√á√ïES ‚úÖ
- **Beta**: Aplicado na c√©lula INICIAL do transiente (`initialTransientRpm/Map`)
- **Tau**: Aplicado na c√©lula FINAL do transiente (`finalTransientRpm/Map`)
- **Implementa√ß√£o**: Condi√ß√µes separadas capturadas em `detectTransients()`

#### 5. TAU COM ERRO ABSOLUTO ‚úÖ
- **Corre√ß√£o**: Tau usa erro absoluto lambda (threshold 0.05f vs 0.02f para beta)
- **Raz√£o**: Tau corrige sobre baseline afetado pelo erro de beta
- **Implementa√ß√£o**: `calculateTauCorrection()` com l√≥gica diferente de beta

#### 6. TAXA DE CORRE√á√ÉO AUMENTADA ‚úÖ
- **Anterior**: 2% por ciclo com ¬±10% bounds
- **Atual**: 5% por ciclo com ¬±15% bounds
- **Implementa√ß√£o**: `correctionRate = 0.05f` e `maxCorrection = 0.15f`

#### 7. CORRE√á√ïES AUTOSCALE REMOVIDAS ‚úÖ
- **Problema**: Multiplica√ß√µes desnecess√°rias por 0.01f e 100.0f
- **Corre√ß√£o**: Aplica√ß√£o direta nas tabelas de corre√ß√£o
- **Implementa√ß√£o**: `applyCorrectionToTable()` sem convers√µes autoscale

#### 8. TAMANHOS DE TABELA CORRIGIDOS ‚úÖ
- **Problema**: Uso incorreto de WWAE_TABLE_SIZE e WWAE_RPM_SIZE para tabelas de corre√ß√£o
- **Corre√ß√£o**: Usar WWAE_CORRECTION_SIZE (8) para todas as tabelas de corre√ß√£o adaptativa
- **Implementa√ß√£o**: `findIndexMsg()` com tamanhos corretos para wwCorrectionMapBins e wwCorrectionRpmBins
- **Tabelas corrigidas**: wwBetaCorrection e wwTauCorrection agora acessadas corretamente

#### 9. MAPEAMENTO DE √çNDICES CORRIGIDO ‚úÖ
- **Problema**: Uso de findIndexMsg() que √© menos eficiente e n√£o segue padr√£o da firmware
- **Corre√ß√£o**: Usar priv::getBin() seguindo o mesmo padr√£o do LTFT (Long Term Fuel Trim)
- **Implementa√ß√£o**: `auto binMap = priv::getBin(map, config->wwCorrectionMapBins); int mapIdx = binMap.Idx;`
- **Vantagens**: Mais eficiente, elegante, e retorna tanto √≠ndice quanto fra√ß√£o para interpola√ß√£o

#### 10. M√âTODO FALTANTE IMPLEMENTADO ‚úÖ
- **Problema**: onActualFuelInjection() chamado por main_trigger_callback.cpp mas n√£o implementado
- **Corre√ß√£o**: Adicionada declara√ß√£o no header e implementa√ß√£o no .cpp
- **Interface**: Adicionado √† interface IWallFuelController como m√©todo virtual puro
- **Override**: Implementa√ß√£o usa `override` para indicar sobrescrita da interface
- **Funcionalidade**: Permite notifica√ß√£o de inje√ß√µes reais para integra√ß√£o futura
- **Debug**: Inclui logging condicional para diagn√≥stico do sistema

#### 11. THRESHOLD DE TAU LEARNING CORRIGIDO ‚úÖ
- **Problema**: Threshold de 50.0f kPa/s impedia transi√ß√£o para fase prolongada, bloqueando tau learning
- **Corre√ß√£o**: Reduzido para 10.0f kPa/s + condi√ß√£o de dura√ß√£o m√≠nima (< 1.0s)
- **Implementa√ß√£o**: `if (transientMagnitude > 10.0f || transientDuration < 1.0f)` para prolonged phase
- **Raz√£o**: Ap√≥s 200ms, derivada diminui mas efeitos de tau ainda s√£o detect√°veis no lambda
- **Debug**: Logging detalhado para verificar transi√ß√µes e identificar transientes incompletos
- **Resultado**: Permite que mais transientes completem ambas as fases (beta + tau)

#### 12. TIMEOUT CR√çTICO CORRIGIDO ‚úÖ
- **PROBLEMA CR√çTICO**: incompleteTimeout de 3.0f segundos quebrava sistematicamente o aprendizado de tau
- **Sequ√™ncia problem√°tica**: Fase imediata (0-200ms) ‚Üí Fase prolongada (200ms-3s) ‚Üí Timeout aos 3s interrompia tau learning
- **Corre√ß√£o**: Aumentado incompleteTimeout de 3.0f para 5.0f segundos
- **Raz√£o**: Timeout deve ser MAIOR que dura√ß√£o total das fases (200ms + 2800ms = 3s)
- **Implementa√ß√£o**: Corrigido tanto no header (.h) quanto na inicializa√ß√£o (.cpp)
- **Resultado**: Permite que fase prolongada complete normalmente para aprendizado de tau
- **Li√ß√£o**: Timeouts devem sempre considerar a dura√ß√£o m√°xima esperada de todas as fases

#### 13. FREQU√äNCIA CR√çTICA CORRIGIDA ‚úÖ
- **PROBLEMA CR√çTICO**: Todos os c√°lculos de timing assumiam onFastCallback a 50Hz, mas a frequ√™ncia real √© 200Hz
- **Evid√™ncia**: `#define FAST_CALLBACK_PERIOD_MS 5` ‚Üí 1000ms √∑ 5ms = 200Hz (n√£o 50Hz!)
- **Impacto**: Buffers subdimensionados e timing incorreto para coleta de lambda
- **Corre√ß√µes aplicadas**:
  - **WW_IMMEDIATE_BUFFER_SIZE**: 10 ‚Üí 40 amostras (200ms a 200Hz)
  - **WW_PROLONGED_BUFFER_SIZE**: 150 ‚Üí 560 amostras (2.8s a 200Hz)
  - **Derivada de carga**: deltaTime corrigido de 160ms para 40ms
- **Resultado**: Timing preciso para coleta de dados de lambda em ambas as fases
- **Li√ß√£o**: Sempre verificar a frequ√™ncia real dos callbacks antes de dimensionar buffers

#### 14. BUFFER DIN√ÇMICO BASEADO EM TAU IMPLEMENTADO ‚úÖ
- **PROBLEMA**: Buffer prolongado com tamanho fixo desperdi√ßava mem√≥ria e n√£o respeitava f√≠sica do tau
- **SOLU√á√ÉO INTELIGENTE**: Buffer din√¢mico dimensionado como m√∫ltiplo da constante de tempo tau
- **Implementa√ß√£o**:
  - **Dura√ß√£o din√¢mica**: `WW_TAU_MULTIPLIER √ó tau` (3√ótau captura ~95% do efeito)
  - **Buffer size**: `dura√ß√£o √ó 200Hz` amostras, limitado a `WW_PROLONGED_BUFFER_SIZE_MAX`
  - **Tau baixo** (0.5s): Buffer de 300 amostras (1.5s) em vez de 560 fixas
  - **Tau alto** (2.0s): Buffer de 1000 amostras (5.0s) em vez de 560 fixas
- **Vantagens**:
  - **Efici√™ncia de mem√≥ria**: Usa apenas o necess√°rio para cada tau
  - **Precis√£o f√≠sica**: Coleta dados pelo tempo correto para cada constante de tempo
  - **Adaptabilidade**: Sistema se ajusta automaticamente √†s condi√ß√µes do motor
- **Debug**: Logging mostra tau atual e dura√ß√£o calculada para diagn√≥stico

#### 15. TRATAMENTO DE TRANSIENTES SOBREPOSTOS IMPLEMENTADO ‚úÖ
- **PROBLEMA**: Novos transientes durante aprendizado contaminam dados de lambda com m√∫ltiplos efeitos sobrepostos
- **CEN√ÅRIO**: Transiente 1 (0ms) ‚Üí Fase beta (0-200ms) ‚Üí Fase tau (200ms-3s) ‚Üí NOVO transiente (800ms) ‚Üí Dados contaminados
- **SOLU√á√ÉO INTELIGENTE**: Detec√ß√£o e reset autom√°tico quando novos transientes interrompem aprendizado
- **Implementa√ß√£o**:
  - **Detec√ß√£o cont√≠nua**: Monitora `transientMagnitude > 50 kPa/s` durante todas as fases
  - **Reset imediato**: Para aprendizado atual e reseta estado quando novo transiente √© detectado
  - **Restart autom√°tico**: Inicia novo ciclo completo (beta + tau) com dados limpos
  - **Prote√ß√£o temporal**: Evita falsos positivos na fase beta (delay de 50ms)
- **Estat√≠sticas de debug**:
  - **interruptedBetaPhases**: Conta interrup√ß√µes durante fase imediata
  - **interruptedTauPhases**: Conta interrup√ß√µes durante fase prolongada  
  - **completedLearningCycles**: Conta ciclos completados com sucesso
- **Vantagens**:
  - **Dados limpos**: Garante que corre√ß√µes s√£o baseadas em transientes √∫nicos
  - **Robustez**: Sistema funciona corretamente mesmo com condu√ß√£o agressiva
  - **Diagn√≥stico**: Estat√≠sticas ajudam a identificar padr√µes de condu√ß√£o problem√°ticos
- **Logging**: Mostra contadores de interrup√ß√£o para an√°lise de qualidade dos dados

#### 15. CORRE√á√ÉO DE CAPTURA DAS CONDI√á√ïES FINAIS IMPLEMENTADA ‚úÖ
- **PROBLEMA CR√çTICO**: finalTransientRpm/Map eram capturadas quando transiente terminava (transientMagnitude < threshold)
- **F√çSICA INCORRETA**: Tau deve ser corrigido onde efeitos prolongados s√£o OBSERVADOS, n√£o onde transiente para
- **TIMING ERRADO**: Captura no fim do transiente ignora que tau atua durante toda a fase prolongada (200ms-3s)
- **CORRE√á√ÉO IMPLEMENTADA**: Captura cont√≠nua durante fase prolongada em updateLambdaResponse()
- **IMPLEMENTA√á√ÉO**: Condi√ß√µes finais atualizadas a cada amostra da fase prolongada (√∫ltimas condi√ß√µes v√°lidas s√£o usadas)
- **FALLBACK**: Se condi√ß√µes finais n√£o foram capturadas, usar condi√ß√µes atuais antes de aplicar corre√ß√µes
- **RESULTADO**: Tau corrigido nas condi√ß√µes corretas onde efeitos s√£o realmente observados no lambda
- **LOCALIZA√á√ÉO**: Removida captura em detectTransients(), adicionada em updateLambdaResponse() durante fase prolongada

#### 16. TAXAS DE APRENDIZADO CONFIGUR√ÅVEIS IMPLEMENTADAS ‚úÖ
- **PROBLEMA**: Taxas de corre√ß√£o fixas (0.10f) no c√≥digo n√£o permitiam ajuste fino sem recompila√ß√£o
- **SOLU√á√ÉO**: Substitui√ß√£o por par√¢metros configur√°veis `engineConfiguration->wwBetaLearningRate` e `wwTauLearningRate`
- **IMPLEMENTA√á√ÉO BETA**: `const float correctionRate = engineConfiguration->wwBetaLearningRate;` em calculateBetaCorrection()
- **IMPLEMENTA√á√ÉO TAU**: `const float correctionRate = engineConfiguration->wwTauLearningRate;` em calculateTauCorrection()
- **VANTAGENS**: Ajuste fino via TunerStudio, diferentes taxas para beta vs tau, sem necessidade de recompila√ß√£o
- **FLEXIBILIDADE**: Usu√°rio pode ajustar agressividade baseado no comportamento espec√≠fico do motor
- **TUNING SUGERIDO**: Taxa baixa (0.05) para motores est√°veis, taxa alta (0.15) para aprendizado r√°pido
- **RESULTADO**: Sistema mais flex√≠vel e tun√°vel para diferentes aplica√ß√µes e prefer√™ncias do usu√°rio

### RESULTADO FINAL CORRIGIDO ‚úÖ
Sistema adaptativo agora implementa corretamente:
- **F√≠sica real**: Beta e tau atuam em AMBOS os tipos de transiente (positivos e negativos)
- **Sequ√™ncia correta**: Qualquer transiente ‚Üí fase imediata (beta) ‚Üí fase prolongada (tau)
- **Timing preciso**: 0-200ms para beta, 200ms-3s para tau
- **Localiza√ß√£o correta**: Beta na c√©lula inicial, tau na c√©lula final
- **Erro apropriado**: Relativo para beta, absoluto para tau
- **Taxa efetiva**: 5% de corre√ß√£o por ciclo com ¬±67% bounds (0.33 a 3.00)
- **Dire√ß√µes corretas**: Lambda lean ‚Üí aumentar beta/tau; Lambda rich ‚Üí diminuir beta/tau
- **Tabelas corretas**: Sem corre√ß√µes autoscale desnecess√°rias
- **Transientes incompletos**: Beta-only correction com timeout de 3s
- **Flexibilidade**: Adapta-se a transientes curtos e longos automaticamente
- **Desacoplamento beta-tau**: Per√≠odos de adapta√ß√£o separados (50 transientes cada)
- **Estabilidade**: Elimina oscila√ß√µes causadas por acoplamento entre par√¢metros
- **Robustez**: Prote√ß√£o completa contra NaN, bounds checking, e valida√ß√£o de dados
- **Gest√£o de estado**: Inicializa√ß√£o correta, flags gerenciados adequadamente
- **Debug avan√ßado**: Logging detalhado para diagn√≥stico e tuning
- **Implementa√ß√£o robusta**: Baseada em pesquisa real de wall wetting (SAE 810494)

### PROBLEMA CR√çTICO: ACOPLAMENTO BETA-TAU ‚ö†Ô∏è

#### AN√ÅLISE DO PROBLEMA ‚ö†Ô∏è
**Equa√ß√£o do Wall Wetting**:
```cpp
float M_cmd = (desiredMassGrams - (1 - alpha) * fuelFilmMass) / (1 - beta);
```

**Problema**: Erros na estimativa de beta afetam diretamente a corre√ß√£o de tau:
- **Beta incorreto** ‚Üí **M_cmd incorreto** ‚Üí **fuelFilmMass incorreto** ‚Üí **Tau correction baseada em dados contaminados**
- **Instabilidade**: Corre√ß√µes simult√¢neas podem causar oscila√ß√µes
- **Converg√™ncia lenta**: Par√¢metros se "perseguem" mutuamente

#### SOLU√á√ÉO: PER√çODOS DE ADAPTA√á√ÉO SEPARADOS ‚úÖ
- **Per√≠odo Beta**: Adaptar apenas beta, manter tau fixo
- **Per√≠odo Tau**: Adaptar apenas tau, manter beta fixo  
- **Altern√¢ncia**: Ciclos de 10-20 transientes para cada par√¢metro
- **Estabiliza√ß√£o**: Permite cada par√¢metro convergir independentemente

### SOLU√á√ÉO PARA ACOPLAMENTO BETA-TAU IMPLEMENTADA ‚úÖ

#### 1. PER√çODOS DE ADAPTA√á√ÉO SEPARADOS ‚úÖ
- **Per√≠odo Beta**: 30 transientes (2 ciclos √ó 15 transientes) adaptando apenas beta
- **Per√≠odo Tau**: 30 transientes (2 ciclos √ó 15 transientes) adaptando apenas tau
- **Altern√¢ncia autom√°tica**: Sistema alterna entre per√≠odos automaticamente
- **Estabiliza√ß√£o**: Cada par√¢metro converge independentemente

#### 2. L√ìGICA DE CONTROLE IMPLEMENTADA ‚úÖ
- **`updateAdaptationMode()`**: Gerencia altern√¢ncia entre per√≠odos
- **`shouldAdaptBeta()`**: Determina se beta deve ser adaptado
- **`shouldAdaptTau()`**: Determina se tau deve ser adaptado
- **Contador de transientes**: Rastreia progresso dentro de cada per√≠odo

#### 3. BENEF√çCIOS DA SOLU√á√ÉO ‚úÖ
- **Elimina instabilidade**: Par√¢metros n√£o se "perseguem" mutuamente
- **Converg√™ncia mais r√°pida**: Cada par√¢metro converge sem interfer√™ncia
- **Dados limpos**: Tau √© adaptado com beta estabilizado
- **Flexibilidade**: Pode ser configurado para diferentes dura√ß√µes de per√≠odo

#### 4. CONFIGURA√á√ÉO IMPLEMENTADA ‚úÖ
- **15 transientes por ciclo**: Per√≠odo suficiente para converg√™ncia parcial
- **2 ciclos por par√¢metro**: Total de 30 transientes por per√≠odo
- **Logging detalhado**: Debug das mudan√ßas de per√≠odo e corre√ß√µes aplicadas
- **Reset no ignition**: Reinicia ciclo a cada partida do motor

### CORRE√á√ïES DE ROBUSTEZ IMPLEMENTADAS ‚úÖ

#### 1. PROTE√á√ÉO CONTRA NaN ‚úÖ
- **Entrada**: Verifica√ß√£o de NaN em todos os inputs de lambda error
- **C√°lculos**: Prote√ß√£o contra NaN em multiplica√ß√µes e divis√µes
- **Sa√≠da**: Verifica√ß√£o de NaN antes de aplicar corre√ß√µes √†s tabelas
- **Fallback**: Retorna 1.0f (sem corre√ß√£o) para valores inv√°lidos

#### 2. VERIFICA√á√ïES DE BOUNDS ‚úÖ
- **Buffers circulares**: Verifica√ß√£o de √≠ndices antes de acesso aos arrays
- **Contadores**: Limita√ß√£o de loops baseada no tamanho real dos buffers
- **Divis√£o por zero**: Prote√ß√£o contra distance = 0 no smoothing
- **Array bounds**: Verifica√ß√£o de limites em todos os acessos a arrays

#### 3. L√ìGICA DE TRANSIENTES CORRIGIDA ‚úÖ
- **Detec√ß√£o**: Usa transientMagnitude em vez de flags que podem ser limpos
- **Threshold**: Verifica√ß√£o consistente de 50.0f kPa/s para transientes ativos
- **Estado**: Evita condi√ß√µes sempre falsas na l√≥gica de transientes

#### 4. VALIDA√á√ÉO DE DADOS ‚úÖ
- **Amostras v√°lidas**: Conta apenas amostras n√£o-NaN para m√©dias
- **Fallback**: Reset e retorno antecipado se n√£o h√° dados v√°lidos
- **Robustez**: Sistema continua funcionando mesmo com dados corrompidos

### CORRE√á√ïES DE GEST√ÉO DE ESTADO IMPLEMENTADAS ‚úÖ

#### 1. INICIALIZA√á√ÉO CORRETA DE VALORES CR√çTICOS ‚úÖ
- **adaptationCycleLength**: Inicializado para 10 transientes por ciclo
- **betaAdaptationCycles**: Inicializado para 5 ciclos (50 transientes total)
- **tauAdaptationCycles**: Inicializado para 5 ciclos (50 transientes total)
- **incompleteTimeout**: Inicializado para 3.0 segundos
- **Dupla inicializa√ß√£o**: Na estrutura e no onIgnitionStateChanged()

#### 2. PROTE√á√ÉO CONTRA DIVIS√ÉO POR ZERO MELHORADA ‚úÖ
- **Tau check**: Verifica√ß√£o mais rigorosa (0.001f em vez de 0.01f)
- **RPM check**: Mantido 100 RPM para opera√ß√£o pr√°tica
- **Produto RPM√óTau**: Verifica√ß√£o adicional antes do c√°lculo de alpha
- **Prote√ß√£o dupla**: Evita divis√£o por zero em qualquer condi√ß√£o

#### 3. GEST√ÉO CORRETA DE FLAGS DE TRANSIENTE ‚úÖ
- **Problema**: Flags eram limpos muito cedo, causando conflitos
- **Solu√ß√£o**: Flags s√≥ s√£o limpos ap√≥s processamento completo
- **Localiza√ß√£o**: Limpeza movida para applyAdaptiveCorrections()
- **Benef√≠cio**: updateLambdaResponse pode usar flags corretamente

#### 4. ATUALIZA√á√ÉO CONT√çNUA DE TRANSIENT MAGNITUDE ‚úÖ
- **Problema**: transientMagnitude desatualizado durante processamento
- **Solu√ß√£o**: Atualiza√ß√£o cont√≠nua no onFastCallback()
- **Remo√ß√£o**: Duplica√ß√£o removida do detectTransients()
- **Precis√£o**: Detec√ß√£o mais precisa de transientes ativos

#### 5. LOGGING DETALHADO PARA DEBUG ‚úÖ
- **Estado de adapta√ß√£o**: Mostra transiente atual e modo ativo
- **Mudan√ßas de per√≠odo**: Log quando alterna entre beta e tau
- **Contadores**: Rastreamento de progresso dentro de cada ciclo
- **Diagn√≥stico**: Facilita debug e tuning do sistema

### CORRE√á√ÉO DE TAU BASEADA EM TEND√äNCIA IMPLEMENTADA ‚úÖ

#### PROBLEMA IDENTIFICADO ‚ö†Ô∏è
**Problema**: A corre√ß√£o de tau estava baseada na m√©dia do erro de lambda, mascarando problemas importantes:
- **Exemplo**: Lambda rico no in√≠cio (-0.05) + lean no final (+0.05) = m√©dia zero (0.00)
- **Resultado**: Sistema pensava que tau estava correto, mas na verdade estava muito baixo
- **F√≠sica**: Tau incorreto causa instabilidade temporal do lambda, n√£o apenas erro m√©dio

#### SOLU√á√ÉO IMPLEMENTADA ‚úÖ
**Nova abordagem**: An√°lise de regress√£o linear para detectar tend√™ncia/slope do lambda ao longo do tempo:

```cpp
// An√°lise de tend√™ncia linear: y = mx + b (onde m = slope)
float slope = (validSamples * sumXY - sumX * sumY) / (validSamples * sumX2 - sumX * sumX);

// Interpreta√ß√£o f√≠sica:
// Slope positivo (lambda fica mais lean) ‚Üí tau muito baixo ‚Üí aumentar tau
// Slope negativo (lambda fica mais rich) ‚Üí tau muito alto ‚Üí diminuir tau  
// Slope ~zero (lambda est√°vel) ‚Üí tau correto ‚Üí sem corre√ß√£o
```

#### VANTAGENS DA NOVA IMPLEMENTA√á√ÉO ‚úÖ
1. **Detecta problemas mascarados**: Identifica tau incorreto mesmo com m√©dia aceit√°vel
2. **F√≠sica correta**: Tau controla estabilidade temporal, n√£o apenas n√≠vel m√©dio
3. **Robustez**: Requer m√≠nimo 10 amostras para an√°lise significativa
4. **Threshold inteligente**: Slope > 0.001f para evitar corre√ß√µes desnecess√°rias
5. **Prote√ß√£o contra NaN**: Verifica√ß√µes completas em todos os c√°lculos

#### EXEMPLOS PR√ÅTICOS ‚úÖ
- **Tau muito baixo**: Lambda -0.05 ‚Üí -0.02 ‚Üí +0.01 ‚Üí +0.04 (slope +0.003) ‚Üí Aumentar tau
- **Tau muito alto**: Lambda +0.03 ‚Üí +0.01 ‚Üí -0.02 ‚Üí -0.05 (slope -0.003) ‚Üí Diminuir tau
- **Tau correto**: Lambda -0.01 ‚Üí -0.01 ‚Üí -0.01 ‚Üí -0.01 (slope ~0.000) ‚Üí Sem corre√ß√£o

#### IMPLEMENTA√á√ÉO T√âCNICA ‚úÖ
- **Fun√ß√£o**: `calculateTauCorrection()` sem par√¢metros (analisa buffer diretamente)
- **Algoritmo**: Regress√£o linear simples sobre dados da fase prolongada
- **Threshold**: M√≠nimo 10 amostras v√°lidas e |slope| > 0.001f
- **Corre√ß√£o**: `correction = 1.0f - (slope * correctionRate * 100.0f)`
- **Bounds**: ¬±67% (0.33 a 3.00) para seguran√ßa

### F√çSICA CORRETA PARA TRANSIENTES POSITIVOS VS NEGATIVOS IMPLEMENTADA ‚úÖ

#### PROBLEMA IDENTIFICADO ‚ö†Ô∏è
**Problema**: O sistema n√£o considerava que a f√≠sica do wall wetting √© DIFERENTE para acelera√ß√µes vs desacelera√ß√µes:
- **Acelera√ß√£o**: Mais combust√≠vel bate nas paredes, combust√≠vel se acumula
- **Desacelera√ß√£o**: Menos combust√≠vel bate nas paredes, combust√≠vel existente evapora das paredes

#### SOLU√á√ÉO IMPLEMENTADA ‚úÖ
**Nova abordagem**: Corre√ß√µes espec√≠ficas baseadas na dire√ß√£o do transiente:

```cpp
// Beta correction com dire√ß√£o do transiente
if (isPositiveTransient) {
    // ACELERA√á√ÉO: Mais combust√≠vel gruda nas paredes
    correction = 1.0f - (avgLambdaError * correctionRate);
} else if (isNegativeTransient) {
    // DESACELERA√á√ÉO: Combust√≠vel evapora das paredes (f√≠sica invertida)
    correction = 1.0f + (avgLambdaError * correctionRate * 0.5f);
}

// Tau correction com dire√ß√£o do transiente
if (isPositiveTransient) {
    // ACELERA√á√ÉO: Combust√≠vel se acumula nas paredes
    correction = 1.0f - (slope * correctionRate * 100.0f);
} else if (isNegativeTransient) {
    // DESACELERA√á√ÉO: Combust√≠vel evapora das paredes (f√≠sica invertida)
    correction = 1.0f + (slope * correctionRate * 100.0f);
}
```

#### F√çSICA CORRETA IMPLEMENTADA ‚úÖ
1. **Beta em Acelera√ß√£o**: Lambda lean ‚Üí aumentar beta; Lambda rich ‚Üí diminuir beta
2. **Beta em Desacelera√ß√£o**: Lambda lean ‚Üí diminuir beta; Lambda rich ‚Üí aumentar beta (invertido)
3. **Tau em Acelera√ß√£o**: Slope positivo ‚Üí aumentar tau; Slope negativo ‚Üí diminuir tau
4. **Tau em Desacelera√ß√£o**: Slope positivo ‚Üí diminuir tau; Slope negativo ‚Üí aumentar tau (invertido)

#### VANTAGENS DA IMPLEMENTA√á√ÉO ‚úÖ
1. **F√≠sica correta**: Respeita comportamento real do wall wetting em ambas as dire√ß√µes
2. **Precis√£o melhorada**: Corre√ß√µes espec√≠ficas para cada tipo de transiente
3. **Robustez**: Fatores reduzidos para desacelera√ß√£o (0.5x) para evitar over-correction
4. **Fallback**: Comportamento conservativo quando dire√ß√£o n√£o √© clara
5. **Compatibilidade**: Mant√©m funcionamento para transientes mistos ou indefinidos

### AN√ÅLISE COMPLETA DO FUNCIONAMENTO DO SISTEMA ‚úÖ

#### FLUXO DE EXECU√á√ÉO ANALISADO ‚úÖ
**Frequ√™ncia**: 200Hz (onFastCallback a cada 5ms)
**Sequ√™ncia**: updateLoadDerivative() ‚Üí detectTransients() ‚Üí updateLambdaResponse()
**Detec√ß√£o**: Threshold 50 kPa/s, buffer circular 8 amostras (40ms hist√≥rico)
**Fases**: Imediata (0-200ms, 40 amostras) ‚Üí Prolongada (din√¢mica 3√ótau, at√© 1000 amostras)

#### PONTOS FORTES IDENTIFICADOS ‚úÖ
1. **F√≠sica correta**: Beta/tau com comportamento espec√≠fico para acelera√ß√£o vs desacelera√ß√£o
2. **Robustez t√©cnica**: Prote√ß√£o NaN, bounds checking, detec√ß√£o transientes sobrepostos
3. **Desacoplamento**: Per√≠odos alternados (50 transientes beta, 50 tau) evitam instabilidade
4. **An√°lise inteligente**: Tau usa regress√£o linear (slope) em vez de m√©dia simples
5. **Prote√ß√£o dados**: Reset autom√°tico quando novos transientes contaminam aprendizado

#### PROBLEMAS POTENCIAIS IDENTIFICADOS ‚ö†Ô∏è
1. **Taxa corre√ß√£o agressiva**: 10% por transiente pode causar overshoot/oscila√ß√µes
2. **Threshold alto**: 50 kPa/s pode perder transientes menores mas significativos  
3. **Per√≠odos fixos**: 50 transientes pode ser longo demais para converg√™ncia r√°pida
4. **Condu√ß√£o agressiva**: Transientes sobrepostos frequentes reduzem aprendizado efetivo

#### CONVERG√äNCIA ESPERADA ‚úÖ
- **Beta**: 6 transientes para converg√™ncia inicial (reduzido de 30-50)
- **Tau**: 6 transientes para converg√™ncia inicial (reduzido de 50-80)
- **Total**: 12 transientes para sistema estabilizado (reduzido de 100-150)
- **Tempo real**: 15-30 minutos de condu√ß√£o variada (reduzido de 2-4 horas)
- **Resultado**: Sistema CONVERGE muito mais rapidamente com per√≠odos reduzidos

#### RECOMENDA√á√ïES DE MELHORIA üîß
1. **Reduzir taxa corre√ß√£o**: De 10% para 5% (mais est√°vel)
2. **Baixar threshold**: De 50 para 30 kPa/s (mais sens√≠vel)
3. **Per√≠odos adaptativos**: Baseados na magnitude das corre√ß√µes
4. **Converg√™ncia adaptativa**: Reduzir taxa quando corre√ß√µes ficam pequenas
5. **Threshold din√¢mico**: Baseado no ru√≠do atual do MAP sensor
6. **‚úÖ IMPLEMENTADO**: Per√≠odos reduzidos para 6 transientes cada (2√ó3 em vez de 10√ó5)