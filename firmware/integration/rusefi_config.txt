
! this file defines the format of rusEfi persistent configuration structure
! this file is processed by ../java_tools/config_definition.jar tool
! comments start with '!'
!
!
! rusEfi configuration consistes of two parts:
! First part is engine_configuration_s area, followed by a few tuning tables
!
! The only difference her is that engine_configuration_s area does not support hot modification while tuning tables could
! be modified without burning changes
!
!
! See also ../tunerstudio/readme.txt
!
! Q: How to add new fields?
! A: Find an 'unused' bit or unused int (usually the huge unusedEnd[] array at the end
!    rename the bit or subsctitute unused intereger with any new fields of the same size
!    invoke gen_config.bat to apply the tools which would generate .h and .ini files
!
!
! each field is declared as
! type name;comment


! all the sub-structures are going to be nested withint the primary structure, that's
! needed to get a proper TunerStudio file

! this section is auto-generated by FiringOrderTSLogic.java
#define ignitionPin2logic || ((firingOrder == 2) || (firingOrder == 7) || (firingOrder == 9) || (firingOrder == 11) || (firingOrder == 12))
#define ignitionPin3logic || ((firingOrder == 1) || (firingOrder == 3) || (firingOrder == 4) || (firingOrder == 5) || (firingOrder == 9))
#define ignitionPin4logic || ((firingOrder == 5) || (firingOrder == 7) || (firingOrder == 12))
#define ignitionPin5logic || ((firingOrder == 4) || (firingOrder == 12))
#define ignitionPin6logic 
#define ignitionPin7logic || ((firingOrder == 11))
#define ignitionPin8logic || ((firingOrder == 5) || (firingOrder == 11))
#define ignitionPin9logic 
#define ignitionPin10logic 
#define ignitionPin11logic 
#define ignitionPin12logic 

struct persistent_config_s 

struct_no_prefix engine_configuration_s

! todo there is still a spot where this 200 is hard-coded
#define LE_COMMAND_LENGTH 200

! see 'blockingFactor' in rusefi.ini
#define BLOCKING_FACTOR 400

#define FSIO_ANALOG_INPUT_COUNT 4

! this is here so that rusEfi console can access it, too
#define TS_OUTPUT_SIZE 356

!
! this is used to confirm that firmware and TunerStudio are using the same rusefi.ini version
! so not forget to change fileVersion in rusefi.ini
#define TS_FILE_VERSION 20171101

#define WARMUP_TARGET_AFR_SIZE 4

#define MAP_ANGLE_SIZE 8
#define MAP_WINDOW_SIZE 8

#define NARROW_BAND_WIDE_BAND_CONVERSION_SIZE 8

#define CLT_CURVE_SIZE 16
#define CRANKING_CLT_IDLE_CURVE_SIZE 8
#define CLT_CRANKING_CURVE_SIZE 8
#define IDLE_ADVANCE_CURVE_SIZE 8

#define ENGINE_NOISE_CURVE_SIZE 8
#define CLT_TIMING_CURVE_SIZE 8
#define IDLE_VE_CURVE_SIZE 8

#define AUX_DIGITAL_VALVE_COUNT 2

#define IAT_CURVE_SIZE 16

#define VBAT_INJECTOR_CURVE_SIZE 8

#define DWELL_CURVE_SIZE 8

#define CRANKING_CURVE_SIZE 8

#define IGN_LOAD_COUNT 16
#define IGN_RPM_COUNT 16

#define INJECTION_PIN_COUNT 12
#define IGNITION_PIN_COUNT 12
#define EGT_CHANNEL_COUNT 8
#define DIGIPOT_COUNT 4
#define HW_MAX_ADC_INDEX 17
#define TRIGGER_SIMULATOR_PIN_COUNT 3
#define LOGIC_ANALYZER_CHANNEL_COUNT 4
#define FSIO_COMMAND_COUNT 16
#define AUX_PID_COUNT 4

#define FUEL_RPM_COUNT 16
#define FUEL_LOAD_COUNT 16

#define FSIO_TABLE_8 8

#define FSIO_CURVE_8 8
#define FSIO_CURVE_16 16

#define TPS_TPS_ACCEL_TABLE 8
#define MAP_ACCEL_TAPER 8

#define BARO_CORR_SIZE 4

#define MAF_DECODING_COUNT 256

! please note that 1024 here is 4 * FUEL_RPM_COUNT * FUEL_LOAD_COUNT  
custom fuel_table_t	1024 array,   F32,   @OFFSET@, [16x16],"ms",      1,     0,      0.0,   300.0,   2
custom ve_table_t 1024 array,   F32,   @OFFSET@, [16x16],"%", 1, 0, 0, 999.0, 2
custom afr_table_t 256 array,   U08,   @OFFSET@, [16x16],"deg",	   0.1,     0,        0,  25.0,     1 

custom fsio_table_8x8_u8t	64 array,   U08,   @OFFSET@, [8x8],"value",      1,     0,      0.0,   255.0,   0
custom fsio_table_8x8_f32t	256 array,   F32,   @OFFSET@, [8x8],"value",      1,     0,      0.0,   30000.0,   2
custom tps_tps_table_t	256 array,   F32,   @OFFSET@, [8x8],"value",      1,     0,      0.0,   30000.0,   2


! todo support table size multiplocation
custom baro_corr_table_t 64 array,   F32,   @OFFSET@, [@@BARO_CORR_SIZE@@x@@BARO_CORR_SIZE@@],"%", 1, 0, 0, 999.0, 2


! please note that 1024 here is 4 * IGN_LOAD_COUNT * IGN_RPM_COUNT  
custom ignition_table_t	1024 array,   F32,   @OFFSET@, [16x16],"deg",	   1,     0,     -20, 90,    2

custom angle_table_t	1024 array,   F32,   @OFFSET@, [16x16],"deg",	   1,     0,     -720,  720,    2

struct pid_s
	float pFactor;;"",      1,      0,       -10000, 10000,      7
	float iFactor;;"",      1,      0,       -10000, 10000,      7
	float dFactor;;"",      1,      0,       -10000, 10000,      7
	int16_t offset;Linear addition to PID logic;"",      1,      0,       0, 1000,      0
	int16_t period;PID dTime;"ms",      1,      0,       0, 3000,      0
	int16_t minValue;;"",        1,     0,  0,    3000.0,  3
	int16_t maxValue;;"",        1,     0,  0,    3000.0,  3
end_struct

struct cranking_parameters_s
float baseFuel;+Fuel squirt duration while cranking\nA number of curves adjust this value according to CLT/IAT/TPS etc;"ms",       1,     0,    0, 200,     1
int16_t rpm;+Cranking mode threshold. Special cranking logic controls fuel and spark while RPM is below this threshold\nset cranking_rpm X;"RPM",      1,     0,    0, 3000,      0
end_struct

#define debug_mode_e_enum "Alternator_PID", "TPS accel enrich", "Warmup PID", "IDLE", "EL accl enrich", "Trigger Counters", "FSIO_ADC", "AUX_PID_1", "VVT PID", "Cranking", "Timing", "Closed-loop fuel corr PID", "VSS", "SD card", "sr5", "Knock", "Trigger Sync", "Electronic Throttle", "Executor", "Bench Test", "Aux Valves", "ADC", "INSTANT_RPM", "FSIO_EXPRESSION", "Status", "mode25", "mode26", "mode27", "mode28", "mode29"
custom debug_mode_e 4 bits,    U32,   @OFFSET@, [0:4], @@debug_mode_e_enum@@

#define vvt_mode_e_enum "First half", "Second half", "2GZ", "Miata NB2", "mode4", "mode5", "mode6", "mode7"
custom vvt_mode_e 4 bits,    U32,   @OFFSET@, [0:2], @@vvt_mode_e_enum@@


#define mass_storage_e_enum "Auto", "Always", "Never"
custom mass_storage_e 4 bits, U32, @OFFSET@, [0:1], @@mass_storage_e_enum@@

! At the moment TIM1, TIM2, TIM3 and TIM9 are configured as ICU
! todo: as of ChibiOS3, only channels 1 & 2 are allowed to capture input, that's a ChibiOS driver limitation
! https://github.com/ChibiOS/ChibiOS-Drivers/blob/master/inc/timcap_driver.h is an alternative driver if channels 3 & 4 really become an issue
! todo: only one channel per timer is allowed for capture similtaniously, that's an STM32 limitation
! todo: convert slow ADC to software scheduler and make TIM8 available
! todo: maybe convert fast ADC to software scheduler as well? less sure about that

#define brain_input_pin_e_enum "INVALID", "PA1", "PA2", "PA3", "INVALID", "PA5", "PA6", "PA7", "PA8", "PA9", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "PA15",  "INVALID", "INVALID", "INVALID", "PB3", "PB4", "PB5", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "PC6", "PC7", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "PE5", "PE6", "INVALID", "INVALID", "PE9", "INVALID", "PE11", "INVALID", "INVALID", "INVALID", "INVALID",    "NONE",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID"
custom brain_input_pin_e 4 bits,    U32,   @OFFSET@, [0:6], @@brain_input_pin_e_enum@@

#define brain_pin_e_enum       "PA0",     "PA1", "PA2", "PA3", "PA4",     "PA5", "PA6", "PA7", "PA8", "PA9", "PA10",     "PA11",   "PA12",    "PA13",    "PA14",    "PA15",  "PB0",     "PB1",     "PB2",     "PB3", "PB4", "PB5", "PB6", "PB7", "PB8", "PB9", "PB10", "PB11", "PB12", "PB13", "PB14", "PB15", "PC0", "PC1", "PC2", "PC3", "PC4", "PC5", "PC6", "PC7", "PC8", "PC9", "PC10", "PC11", "PC12", "PC13", "PC14", "PC15", "PD0", "PD1", "PD2", "PD3", "PD4", "PD5", "PD6", "PD7", "PD8", "PD9", "PD10", "PD11", "PD12", "PD13", "PD14", "PD15", "PE0", "PE1", "PE2", "PE3", "PE4", "PE5", "PE6", "PE7", "PE8", "PE9", "PE10", "PE11", "PE12", "PE13", "PE14", "PE15",    "NONE",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID"

custom brain_pin_e 4 bits,    U32,   @OFFSET@, [0:6], @@brain_pin_e_enum@@
#define pin_output_mode_e_enum "default", "default inverted", "open collector", "open collector inverted"
custom pin_output_mode_e 4 bits,    U32,   @OFFSET@, [0:1], @@pin_output_mode_e_enum@@

custom air_pressure_sensor_type_e 4 bits, U32, @OFFSET@, [0:2]  "Custom", "DENSO183", "MPX4250", "HONDA3BAR", "NEON_2003", "22012AA090", "3 Bar", "INVALID"
#define adc_channel_e_enum "PA0", "PA1", "PA2", "PA3", "PA4", "PA5", "PA6", "PA7", "PB0", "PB1", "PC0", "PC1", "PC2", "PC3", "PC4", "PC5", "Disabled", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID"
custom adc_channel_e 4 bits, U32, @OFFSET@, [0:4]  @@adc_channel_e_enum@@

struct air_pressure_sensor_config_s
float lowValue;kPa value at low volts;"kpa",      1,     0,    -400, 800,     2
float highValue;kPa value at high volts;"kpa",      1,     0,    -400, 800,     2
air_pressure_sensor_type_e type;
adc_channel_e hwChannel;
end_struct

struct MAP_sensor_config_s @brief MAP averaging configuration
float[MAP_ANGLE_SIZE] samplingAngleBins;;"",      1,     0,   0.0,    18000,   2
float[MAP_ANGLE_SIZE] samplingAngle;@brief MAP averaging sampling start angle, by RPM;"deg",      1,     0,   -180,    180,   2
float[MAP_WINDOW_SIZE] samplingWindowBins;;"",      1,     0,   0.0,    18000,   2
float[MAP_WINDOW_SIZE] samplingWindow;@brief MAP averaging angle duration, by RPM;"deg",      1,     0,   0,    180,   2
air_pressure_sensor_config_s sensor
end_struct

struct_no_prefix thermistor_conf_s @brief Thermistor known values
float tempC_1;these values are in Celcuus;"*C",       1,     0,    -40, 200,     1
float tempC_2;;"*C",       1,     0,    -40, 200,     1
float tempC_3;;"*C",       1,     0,    -40, 200,     1
float resistance_1;;"Ohm",      1,     0,    0, 200000,     1
float resistance_2;;"Ohm",      1,     0,    0, 200000,     1
float resistance_3;;"Ohm",      1,     0,    0, 200000,     1

	float bias_resistor;;"Ohm",      1,     0,    0, 200000,     1
end_struct

struct oil_pressure_config_s @brief Oil pressure sensor interpolation
	adc_channel_e hwChannel;
	float v1;;         "volts",    1,    0.0,       0,    10.0,        2
	float value1;;     "kPa",    1,      0.0,       0,  1000.0,        2
	float v2;;         "volts",    1,    0.0,       0,    10.0,        2
	float value2;;     "kPa",    1,      0.0,       0,  1000.0,        2
end_struct

struct ThermistorConf @brief Thermistor curve parameters
	thermistor_conf_s config;
	adc_channel_e adcChannel;
end_struct

custom engine_type_e 4 bits, S32, @OFFSET@,   [0:2], "AUDI_AAN", "DODGE_NEON_1995", "FORD_ASPIRE_1996", "FORD_FIESTA", "NISSAN_PRIMERA", "HONDA_ACCORD", "FORD_INLINE_6_1995", "GY6_139QMB"
engine_type_e engineType;http://rusefi.com/wiki/index.php?title=Manual:Engine_Type\nset engine_type X

int engineSnifferRpmThreshold;Engine sniffer would be disabled above this rpm\nset engineSnifferRpmThreshold X;"RPM",      1,     0,    0,30000,      0

struct injector_s
	float flow;+cc/min, cubic centimeter per minute\nBy the way, g/s = 0.125997881 * (lb/hr)\ng/s = 0.125997881 * (cc/min)/10.5\ng/s = 0.0119997981 * cc/min;"cm3/min",  1,     0,      0,   1000,   2

float[VBAT_INJECTOR_CURVE_SIZE] battLagCorrBins;set_flat_injector_lag LAG\nset_injector_lag VOLTAGE LAG;"volts",        1,     0,      0.0,    20.0,   2
float[VBAT_INJECTOR_CURVE_SIZE] battLagCorr;ms delay between injector open and close dead times;"ms",     1,     0,      0.0,    50.0,   2

end_struct

struct bi_quard_s
	float a0;;"v",  1,     0,      -1000,   1000,   9
	float a1;;"v",  1,     0,      -1000,   1000,   9
	float a2;;"v",  1,     0,      -1000,   1000,   9
	float b1;;"v",  1,     0,      -1000,   1000,   9
	float b2;;"v",  1,     0,      -1000,   1000,   9

end_struct

injector_s injector


bit directSelfStimulation;+Should trigger emulator push data right into trigger handling logic, eliminating the need for physical jumper wires?\nPS: Funny name, right? :)
bit activateAuxPid1;
bit isVerboseAuxPid1;
bit activateAuxPid2;
bit isVerboseAuxPid2;
bit activateAuxPid3;
bit isVerboseAuxPid3;
bit activateAuxPid4;
bit isVerboseAuxPid4;
bit useBiQuadAnalogFiltering;
bit issue_294_10;
bit issue_294_11;
bit issue_294_12;
bit issue_294_13;
bit issue_294_14;
bit issue_294_15;
bit issue_294_16;
bit issue_294_17;
bit issue_294_18;
bit issue_294_19;
bit issue_294_21;
bit issue_294_22;
bit issue_294_23;
bit issue_294_24;
bit issue_294_25;
bit issue_294_26;
bit issue_294_27;
bit issue_294_28;
bit issue_294_29;


int16_t tpsMin;Closed throttle. todo: extract these two fields into a structure\ntodo: we need two sets of TPS parameters - modern ETBs have two sensors;"ADC",      1,     0,    0, 1023,      0
int16_t tpsMax;Full throtle. tpsMax value as 10 bit ADC value. Not Voltage!;"ADC",      1,     0,    0, 1023,      0

int16_t tpsErrorDetectionTooLow;TPS error detection, what TPS % value is unrealistically low;"%",       1,     0,    -40, 200,     0
int16_t tpsErrorDetectionTooHigh;;"%",       1,     0,    -40, 200,     0

cranking_parameters_s cranking
float primingSquirtDurationMs;;"*C",       1,     0,    -40, 200,     1
	float ignitionDwellForCrankingMs;;"ms",        1,     0,    0, 200,     1
float crankingChargeAngle;+While cranking (which causes battery voltage to drop) we can calculate dwell time in shaft\ndegrees, not in absolute time as in running mode.\nset cranking_charge_angle X;"deg",    1,      0,       0,  3000.0,      0


MAP_sensor_config_s map;@see hasMapSensor\n@see isMapAveragingEnabled


ThermistorConf clt;todo: merge with channel settings, use full-scale Thermistor here!
ThermistorConf iat;
	
	int step1rpm;A secondary Rev limit engaged by the driver to help launch the vehicle faster;"rpm",    1,      0,       0, 20000.0,        2
	int step1timing;;"deg",    1,      0,       -180, 180,        2
	int hip9011PrescalerAndSDO;6=8MHz todo solit two bit fields;"integer", 1, 0.0, 0.0, 32, 0
	float knockBandCustom;+kHz knock band override;"kHz", 1, 0.0, 0.0, 10.0, 2


float[DWELL_CURVE_SIZE] sparkDwellRpmBins;On single-coil or wasted spark setups you have to lower dwell at high RPM;"RPM",     1,   0.0,      0.0,  18000,   2
	float[DWELL_CURVE_SIZE] sparkDwellValues;;"ms",	   1,   0.0,      0.0,  30.0,    2

struct_no_prefix specs_s
float displacement;Engine displacement, in liters\nsee also cylindersCount;"L",    1,      0,       0,  1000.0,        2

custom cylinders_count_t 4 bits,    U32,    @OFFSET@, [0:3], "INVALID", 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, "INVALID", "INVALID", "INVALID"
cylinders_count_t cylindersCount;

! see firing_order.h
! FO_1 = 0
! FO_1_3_2_4 = 3
! FO_1_8_4_3_6_5_7_2 = 5
! FO_1_2_4_5_3 = 6

custom firing_order_e 4 bits,    U32,    @OFFSET@, [0:4], "One Cylinder", "1-3-4-2", "1-2-4-3", "1-3-2-4", "1-5-3-6-2-4", "1-8-4-3-6-5-7-2", "1-2-4-5-3", "1-4-2-5-3-6", "1-2", "1_2_3_4_5_6", "1-2-3", "1-8-7-2-6-5-4-3", "1-5-4-2-6-3-7-8", "1-6-3-2-5-4", "1-10-9-4-3-6-5-8-7_2", "1-7-5-11-3-9-6-12-2-8-4-10", "1-7-4-10-2-8-6-12-3-9-5-11", "fo17", "fo18", "fo19", "fo20", "INVALID"
firing_order_e firingOrder;
end_struct

    specs_s specs
	float cylinderBore;+Cylinder diameter, in mm.;"mm",    1,      0,       0, 20000.0,        2
int sensorSnifferRpmThreshold;+Disable sensor sniffer above this rpm;"RPM",      1,     0,    0,30000,      0
	int rpmHardLimit;set rpm_hard_limit X;"rpm",    1,      0,       0, 20000.0,        2


#define engine_load_mode_e_enum "MAF", "Alpha-N/TPS", "MAP", "SPEED DENSITY" 


custom engine_load_mode_e 4 bits, U32, @OFFSET@, [0:1], @@engine_load_mode_e_enum@@
engine_load_mode_e fuelAlgorithm;+This setting controls which fuel quantity control algorithm is used.\nset algorithm X


custom injection_mode_e 4 bits, U32, @OFFSET@, [0:1], "Simultaneous", "Sequential", "Batch", "Single Point"
injection_mode_e crankingInjectionMode;
injection_mode_e injectionMode;+'batched' means two injectors are wired together\nset injection_mode X\nSee also twoWireBatchInjection
angle_t extraInjectionOffset;+this is about deciding when the injector starts it's squirt\nSee also injectionPhase map\ntodo: do we need even need this since we have the map anyway?;"deg",    1,      0.0,       -720,     720,        2
angle_t crankingTimingAngle;+Timing advance while engine cranking\nset cranking_timing_angle X;     "deg",    1,      0.0,    -360,     360,        2

custom ignition_mode_e 4 bits,    U32,    @OFFSET@, [0:1], "One coil", "Individual Coils", "Wasted", "INVALID"
ignition_mode_e ignitionMode;+'wasted' means one coil is driving two spark plugs in two cylinders, with one of the aparks not doing anything since it's happening on the exhaust cycle\nset ignition_mode X

angle_t ignitionOffset;+this value could be used to offset the whole ignition timing table by a constant;"RPM",    1,      0,       0,  3000.0,      0

custom timing_mode_e 4 bits, U32, @OFFSET@ [0:0], "dynamic", "fixed"
timing_mode_e timingMode;

angle_t fixedModeTiming;+This value is used in 'fixed timing' mode, i.e. constant timing\nThis mode is useful for instance while adjusting distributor location;"RPM",    1,      0,       0,  3000.0,      0

angle_t globalTriggerAngleOffset;+Angle between Top Dead Center (TDC) and the first trigger event.\nKnowing this angle allows us to control timing and other angles in reference to TDC.\nset global_trigger_offset_angle X;"deg",    1,      0,       -720,  720, 0



float analogInputDividerCoefficient;+Coefficient of input voltage dividers on your PCB;"coef",    1,      0,    0.01,  10.0,   2
float vbattDividerCoeff;+Battery Voltage input resistor divider coefficient;"coef",    1,      0,    0.01,  99.0,        2
adc_channel_e vbattAdcChannel;

float fanOnTemperature;+Cooling fan turn-on temperature threshold, in Celsuis;"*C",    1,      0,       0,  1000.0,        0
float fanOffTemperature;+Cooling fan turn-off temperature threshold, in Celsuis;"*C",    1,      0,       0,  1000.0,        0

adc_channel_e fuelLevelSensor;

float vehicleSpeedCoef;+This coefficient translates vehicle speed input frequency (in Hz) into vehicle speed, km/h;"coef",    1,      0,    0.01,  2000.0,        2

custom can_nbc_e 4 bits, U32, @OFFSET@, [0:1], "BMW", "FIAT", "VAG" , "MAZDA RX8"
can_nbc_e canNbcType;set can_mode X

int canSleepPeriod;CANbus thread period, ms;"ms",    1,      0,       0,  1000.0,        2


custom operation_mode_e 4 bits,    U32,    @OFFSET@, [0:2], "INVALID", "4 stroke without cam sensor", "4 stroke with cam sensor", "2 stroke", "4 stroke with symmetrical crank", "INVALID", "INVALID", "INVALID"
operation_mode_e operationMode;See engineCycle\nset operation_mode X

custom display_mode_e 4 bits,    U32,    @OFFSET@, [0:1], "none", "hd44780", "hd44780 over pcf8574", "INVALID"
display_mode_e displayMode;

custom log_format_e 4 bits,    U32,    @OFFSET@, [0:0], "native", "Mega Log Viewer"
log_format_e logFormat;
	int byFirmwareVersion;;"index",      1,      0,       0, 300,      0
	int HD44780width;;"index",      1,      0,       0, 300,      0
	int HD44780height;;"index",      1,      0,       0, 300,      0
	
	adc_channel_e tpsAdcChannel;
	int overrideCrankingIgnition;
	int sensorChartFrequency;;"index",      1,      0,       0, 300,      0 ; size 4

struct trigger_config_s @brief Trigger wheel(s) configuration


custom bool32_t 4 bits,    U32,   @OFFSET@, [0:0], "false", "true"

#define trigger_type_e_enum "custom toothed wheel", "Ford Aspire", "Dodge Neon 1995", "Miata NA", "Miata NB", "GM_7X", "Cooper R50", "Mazda SOHC 4", "60/2", "36/1", "Honda 4+24+1", "Mitsubishi", "Honda 4+24", "Honda 1+4+24", "Dodge Neon 2003", "Mazda DOHC 1+4", "1+1", "1+60/2", "Single Tooth", "Dodge Ram 1+16", "60/2 VW", "Honda 1+24", "Dodge Stratus",  "36_2_2_2", "Nissan Primera", "2JZ", "Rover K", "GM LS 24", "Honda CBR 600", "2JZ_1_12", "Honda CBR 600 custom", "3/1 skipped" , "Dodge Neon 2003 crank", "Miata VVT", "trg34", "trg35", "Subaru 7+6", "Jeep 18-2-2-2", "WIP", "trg39", "trg40", "trg41", "trg42", "INVALID"

custom trigger_type_e 4 bits,    U32,   @OFFSET@, [0:5], @@trigger_type_e_enum@@
	trigger_type_e type;set trigger_type X

	bit unusedCustomIsSynchronizationNeeded;
	bit unusedCustomNeedSecondTriggerInput;
	bit useOnlyFirstChannel;+This option could be used if your second trigger channel is broken

	int customTotalToothCount;;"number",    1,      0.0,       0,  500.0,        0
	int customSkippedToothCount;;"number",    1,      0.0,       0,  500.0,        0
end_struct

trigger_config_s trigger;

custom spi_device_e 4 bits,U32,   @OFFSET@, [0:1], "Off", "SPI1", "SPI2", "SPI3" 
	spi_device_e hip9011SpiDevice;
	
	
float globalFuelCorrection;set global_fuel_correction X;"coef",    1,      0.0,       0,  1000.0,        2

	float adcVcc;;         "volts",    1,    0.0,       0,    4.0,        3
	float maxKnockSubDeg;maximum total number of degrees to subtract from ignition advance\nwhen knocking
	adc_channel_e mafAdcChannel;See hasMafSensor	
	
struct afr_sensor_s
	adc_channel_e hwChannel;
	float v1;;         "volts",    1,    0.0,       0,    10.0,        2
	float value1;;     "AFR",    1,      0.0,       0,  1000.0,        2
	float v2;;         "volts",    1,    0.0,       0,    10.0,        2
	float value2;;     "AFR",    1,      0.0,       0,  1000.0,        2

end_struct	
	
afr_sensor_s afr

adc_channel_e pedalPositionChannel;
	
air_pressure_sensor_config_s baroSensor;@see hasBaroSensor	

struct idle_hardware_s
	brain_pin_e solenoidPin;
	pin_output_mode_e solenoidPinMode;

	int solenoidFrequency;;"Hz",      1,      0,       0, 3000,      0

	brain_pin_e stepperDirectionPin;
	brain_pin_e stepperStepPin; 

end_struct
	
struct_no_prefix board_configuration_s
	idle_hardware_s idle;


	float manIdlePosition;value between 0 and 100 used in Manual mode;"%", 1, 0, 0, 100, 0

	brain_pin_e fuelPumpPin;
	pin_output_mode_e fuelPumpPinMode;

	brain_pin_e[INJECTION_PIN_COUNT iterate] injectionPins;
	pin_output_mode_e injectionPinMode;

	brain_pin_e[IGNITION_PIN_COUNT iterate] ignitionPins;
	pin_output_mode_e ignitionPinMode;

	brain_pin_e malfunctionIndicatorPin;
	pin_output_mode_e malfunctionIndicatorPinMode;

	brain_pin_e fanPin;
	pin_output_mode_e fanPinMode;

float mapFrequency0Kpa;;"Hz",      1,      0,       0, 100000,      2
float mapFrequency100Kpa;;"Hz",      1,      0,       0, 100000,      2
brain_pin_e clutchDownPin;some cars have a switch to indicate that clutch pedal is all the way down
	pin_input_mode_e clutchDownPinMode;

	brain_pin_e alternatorControlPin;
	pin_output_mode_e alternatorControlPinMode;

	brain_pin_e HD44780_rs;
	brain_pin_e HD44780_e;
	brain_pin_e HD44780_db4;
	brain_pin_e HD44780_db5;
	brain_pin_e HD44780_db6;
	brain_pin_e HD44780_db7;

	brain_pin_e gps_rx_pin;
	brain_pin_e gps_tx_pin;

! todo: rename to triggerSimulatorRpm
	int triggerSimulatorFrequency;rpm X;"Rpm",     1,      0,       0,30000,      0
	
spi_device_e digitalPotentiometerSpiDevice;Digital Potentiometer is used by stock ECU stimulation code
	brain_pin_e[DIGIPOT_COUNT iterate] digitalPotentiometerChipSelect;

custom adc_channel_mode_e 4 bits,    U32,   @OFFSET@, [0:1], "Off", "Slow", "Fast", "INVALID" 

	brain_pin_e etbDirectionPin1;
	brain_pin_e etbDirectionPin2;
	brain_pin_e etbControlPin1;
	brain_pin_e etbControlPin2;
	pin_output_mode_e electronicThrottlePin1Mode;

	brain_pin_e wboHeaterPin;
	brain_pin_e cj125CsPin;
	float fuelLevelEmptyTankVoltage;;"V",      1,      0,       0,10,      2
	float fuelLevelFullTankVoltage;;"V",      1,      0,       0,10,      2
	ego_sensor_e afr_type;AFR, WBO, EGO - whatever you like to call it;
	float fuelClosedLoopAfrLowThreshold;;"ratio",        1,     0,  0,    100,  1
	pin_output_mode_e hip9011CsPinMode;
	brain_pin_e tachOutputPin;+This implementation produces one pulse per engine cycle. See also dizzySparkOutputPin.
	pin_output_mode_e tachOutputPinMode;

	brain_input_pin_e[3 iterate] triggerInputPins;
	brain_pin_e mainRelayPin;

	int idleThreadPeriod;
	int consoleLoopPeriod;
	int lcdThreadPeriod;
	brain_pin_e sdCardCsPin;
	int generalPeriodicThreadPeriod;

	uint32_t tunerStudioSerialSpeed;;"BPs",      1,      0,       0,1000000,      0

	brain_pin_e boardTestModeJumperPin;

	can_device_mode_e canDeviceMode;
	brain_pin_e canTxPin;
	brain_pin_e canRxPin;
	
	brain_pin_e[TRIGGER_SIMULATOR_PIN_COUNT iterate] triggerSimulatorPins;
	pin_output_mode_e[TRIGGER_SIMULATOR_PIN_COUNT iterate] triggerSimulatorPinModes;

	brain_pin_e o2heaterPin;
	pin_output_mode_e o2heaterPinModeTodO;

bit is_enabled_spi_1
bit is_enabled_spi_2
	bit is_enabled_spi_3
	bit isSdCardEnabled
	bit isFastAdcEnabled
	bit isEngineControlEnabled
	bit isHip9011Enabled
	bit isVerboseAlternator
	bit useSerialPort
	bit useStepperIdle
	
	bit enabledStep1Limiter;
	bit useTpicAdvancedMode;
	bit useLcdScreen;
	bit startConsoleInBinaryMode;
	bit useWarmupPidAfr;
	bit onOffAlternatorLogic;
	bit isCJ125Enabled
	bit vvtCamSensorUseRise;+Use rise or fall signal front
	bit unused_board_984_18
	bit unused_board_984_19
	bit unused_board_984_20
	bit unused_board_984_21
	bit unused_board_984_22
	bit unused_board_984_23
	bit unused_board_984_24
	bit unused_board_984_25
	bit unused_board_984_26
	bit unused_board_984_27
	bit unused_board_984_28
	bit unused_board_984_29
	bit unused_board_984_30

	brain_input_pin_e[LOGIC_ANALYZER_CHANNEL_COUNT iterate] logicAnalyzerPins;
	uint8_t[LOGIC_ANALYZER_CHANNEL_COUNT] logicAnalyzerMode;default or inverted input

	int unrealisticRpmThreashold;

	pin_output_mode_e mainRelayPinMode;

	brain_pin_e[EGT_CHANNEL_COUNT iterate] max31855_cs;

	spi_device_e max31855spiDevice;

	brain_pin_e[FSIO_COMMAND_COUNT iterate] fsioOutputPins;todo: more comments
	pin_output_mode_e[FSIO_COMMAND_COUNT iterate] gpioPinModes;

custom uart_device_e 4 bits,U32,   @OFFSET@, [0:1], "Off", "UART1", "UART2", "UART3" 
	uart_device_e consoleUartDevice;
	int mapMinBufferLength;;"count",        1,     0,  0,    24,  0
	int16_t idlePidDeactivationTpsThreshold;;"%",        1,     0,  0,    100.0,  0
	int16_t idleStepperPulseDuration;;"ms",        1,     0,  0,    1000.0,  0
	float nb2ratioFrom;;"value",      1,      0,       0, 1000,      5
	float nb2ratioTo;;"value",      1,      0,       0, 1000,      5

	brain_pin_e triggerErrorPin;This pin is used for debugging - snap a logic analyzer on it and see if it's ever high
	
	pin_output_mode_e triggerErrorPinMode;

	brain_pin_e acRelayPin;
	pin_output_mode_e acRelayPinMode;

custom pid_dt 4 scalar, U32,  @OFFSET@, "ms",      1,      0,       0, 3000,      0
custom fsio_pwm_freq_t 2 scalar,  U16,   @OFFSET@,         "Hz",      1,      0,       0, 3000,      0
	fsio_pwm_freq_t[FSIO_COMMAND_COUNT iterate] fsioFrequency;

	brain_pin_e hip9011CsPin;
	brain_pin_e hip9011IntHoldPin;
pin_output_mode_e hip9011IntHoldPinMode;
custom fsio_setting_t 4 scalar,  F32,   @OFFSET@, 		"Val",	   1,	   0,       0, 18000,	  4
	fsio_setting_t[FSIO_COMMAND_COUNT iterate] fsio_setting;
	brain_pin_e spi1mosiPin;
	brain_pin_e spi1misoPin;
	brain_pin_e spi1sckPin;
	brain_pin_e spi2mosiPin;
	brain_pin_e spi2misoPin;
	brain_pin_e spi2sckPin;
	brain_pin_e spi3mosiPin;
	brain_pin_e spi3misoPin;
	brain_pin_e spi3sckPin;

	float hip9011Gain;
	brain_pin_e joystickCenterPin;
	brain_pin_e joystickAPin;
	brain_pin_e joystickBPin;
	brain_pin_e joystickCPin;
	brain_pin_e joystickDPin;

#define sensor_chart_e_enum "none", "trigger", "MAP", "RPM ACCEL", "DETAILED RPM", "INVALID"
custom sensor_chart_e 4 bits, S32, @OFFSET@, [0:2], @@sensor_chart_e_enum@@
sensor_chart_e sensorChartMode;+rusEfi console Sensor Sniffer mode

#define ego_sensor_e_enum "BPSX", "Innovate", "14Point7", "Narrow", "PLX", "Custom"
custom ego_sensor_e 4 bits, S32, @OFFSET@, [0:2], @@ego_sensor_e_enum@@

maf_sensor_type_e mafSensorType;

brain_input_pin_e vehicleSpeedSensorInputPin;

	brain_pin_e clutchUpPin;Some vehicles have a switch to indicate that clutch pedal is all the way up
	pin_input_mode_e clutchUpPinMode;
	brain_pin_e[FSIO_COMMAND_COUNT iterate] fsioDigitalInputs;todo:not finshed\nThese input pins allow us to pull toggle buttons state;

brain_input_pin_e frequencyReportingMapInputPin;


end_struct	
custom le_formula_t 200 string, ASCII, @OFFSET@, 200
	
board_configuration_s bc;
bit vvtDisplayInverted
	bit fuelClosedLoopCorrectionEnabled
	bit isVerboseIAC
	bit isVerboseETB;enable verbose_etb
	bit useConstantDwellDuringCranking 
	bit isEngineChartEnabled;This options enables data for 'engine sniffer' tab in console, which comes at some CPU price 
	bit silentTriggerError
	bit useLinearCltSensor
	bit canReadEnabled
	bit canWriteEnabled
	bit useLinearIatSensor
	bit useFSIO16ForTimingAdjustment;See fsioTimingAdjustment
	bit tachPulseDurationAsDutyCycle
	bit isAlternatorControlEnabled
	bit invertPrimaryTriggerSignal
	bit invertSecondaryTriggerSignal
bit cutFuelOnHardLimit
bit cutSparkOnHardLimit
bit step1fuelCutEnable
bit step1SparkCutEnable
bit hasFrequencyReportingMapSensor;
bit unused_bit_1472_21;
bit unused_bit_1472_22
bit unused_bit_1472_23;
bit unused_bit_1472_24;
bit unused_bit_1472_25;
bit unused_bit_1472_26;
bit unused_bit_1472_27;
	adc_channel_e hipOutputChannel;

custom idle_mode_e 4 bits,    U32,   @OFFSET@, [0:0], "Automatic", "Manual"
	idle_mode_e idleMode;

	bit isInjectionEnabled;+enable injection
	bit isIgnitionEnabled;+enable ignition
	bit isCylinderCleanupEnabled;+If TPS above 95% no fuel would be injected during cranking\nenable cylinder_cleanup 
	bit secondTriggerChannelEnabled
	bit needSecondTriggerInputDeprecated
	bit isMapAveragingEnabled
	bit overrideCrankingIacSetting
	bit useSeparateAdvanceForIdle
	bit isTunerStudioEnabled
	bit isWaveAnalyzerEnabled
	bit useSeparateVeForIdle
	bit isPrintTriggerSynchDetails;+enable trigger_details
	bit isManualSpinningMode;Usually if we have no trigger events that means engine is stopped\nUnless we are troubleshooting and spinning the engine by hand - this case a longer\ndelay is needed
	bit twoWireBatchInjection;+This is needed if batched injection and individual injector wiring\nenable two_wire_batch_injection
	bit useOnlyRisingEdgeForTrigger;+VR sensors are only precise on rising front\nenable trigger_only_front
	bit twoWireBatchIgnition;+This is needed if batched igniton (waster spark) and individual coil wiring
bit useFixedBaroCorrFromMap
bit unused_1484_bit_17
bit unused_1484_bit_18
bit unused_1484_bit_19
bit unused_1484_bit_20
bit unused_1484_bit_21

	uint32_t engineChartSize;;"count",      1,      0,       0, 300,      0


	int16_t idlePidRpmUpperLimit;+Relative to the target idle RPM;"RPM",      1,      0,       0, 9000,      0
    int16_t primeInjFalloffTemperature;Prime injection pulse falloff temperature threshold, in Celsuis;"*C",    1,      0,       0,  1000.0,        0

	adc_channel_e acSwitchAdc;A/C button input handled as analog input

	int ignMathCalculateAtIndex;+At what trigger index should some ignition-related math be executed? This is a performance trick to reduce load on synchronization trigger callback.;"index",      1,      0,       0, 7000,      0

	int16_t acCutoffLowRpm;
	int16_t acCutoffHighRpm;

	int16_t acIdleRpmBump;
	int16_t warningPeriod;set warningPeriod X;"seconds",      1,      0,       0, 60,      0

	adc_channel_e vRefAdcChannel;

	float knockDetectionWindowStart;
	float knockDetectionWindowEnd;


float idleStepperReactionTime;;"ms",      1,      0,       1, 300,      0
	float knockVThreshold;;"V",      1,      0,       1, 5,      2

custom pin_input_mode_e 4 scalar, F32,	@OFFSET@,	"ms", 1, 0, 0, 200, 1	
	pin_input_mode_e[FSIO_COMMAND_COUNT iterate] fsioInputModes;
	
	adc_channel_e externalKnockSenseAdc;
	int[3] unsed2342342;
	int idleStepperTotalSteps;;"count",      1,      0,       5, 3000,      0
	brain_pin_e stepperEnablePin;

float noAccelAfterHardLimitPeriodSecs;TODO: finish this #413;"sec",      1,      0,       0, 60,      0

int mapAveragingSchedulingAtIndex;+At what trigger index should some MAP-related math be executed? This is a performance trick to reduce load on synchronization trigger callback.;"index",      1,      0,       0, 7000,      0

float[BARO_CORR_SIZE] baroCorrPressureBins;;"kPa",      1,     0,   0.0,    200,   2
float[BARO_CORR_SIZE] baroCorrRpmBins;;"RPM",      1,     0,   0.0,    18000,   2

baro_corr_table_t baroCorrTable;
	
	#define pin_mode_e_enum "default", "INVALID", "INVALID", "INVALID", "opendrain", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "mode12", "mode13", "mode14", "mode15", "mode16", "mode17", "mode18", "mode19", "mode20", "mode21", "mode22", "mode23", "mode24", "mode25", "mode26", "mode27", "mode28", "mode29", "mode30", "mode31", "PULLUP", "mode33", "mode34", "mode35"
custom pin_mode_e 4 bits,    U32,   @OFFSET@, [0:5], @@pin_mode_e_enum@@
	
	pin_mode_e spi2SckMode;
	pin_mode_e spi2MosiMode;
	pin_mode_e spi2MisoMode;
	
	float[CRANKING_CURVE_SIZE] crankingTpsCoef;Cranking fuel correction coefficient based on TPS;"%",      1,     0,      0.0,    700.0,   2
	float[CRANKING_CURVE_SIZE] crankingTpsBins;;"%",        1,     0,    0.0,    100.0,  2
	
	float tachPulseDuractionMs;;"ms",        1,     0,    0.0,    100.0,  2
	int tachPulseTriggerIndex;+Trigger cycle index at which we start tach pulse (performance consideration);"index",     1,     0,    0.0,    360.0,  0
	
	float suckedOffCoef;;"%",        1,     0,    0.0,    300.0,  2
	pid_s alternatorControl;
	pid_s etb;
	pid_s warmupAfrPid;

! todo: mapErrorDetectionIdleTooLow? 30kPa is usually lowest on idle	
	float mapErrorDetectionTooLow;kPa value which is too low to be true;"kPa",        1,     0,    -100.0,    100.0,  2
	float mapErrorDetectionTooHigh;kPa value which is too high to be true;"kPa",        1,     0,    -100.0,    800.0,  2
	int step1RpmWindow;RPMs prior to step1rpm point where ignition advance is retarded;"rpm",    1,      0,       0, 3000.0,        2
	pid_s idleRpmPid;See cltIdleRpmBins
	float addedToWallCoef;;"%",        1,     0,    0.0,    300.0,  2
	brain_pin_e communicationPin;blue LED on discovery by default	
	brain_pin_e runningPin;green LED on discovery by default
	brain_pin_e binarySerialTxPin;	
	brain_pin_e binarySerialRxPin;	
	brain_pin_e consoleSerialTxPin;	todo: finish pin migration from hard-coded to configurable?
	brain_pin_e consoleSerialRxPin;todo: finish pin migration from hard-coded to configurable?
	float[ENGINE_NOISE_CURVE_SIZE] knockNoise;Knock sensor output knock detection threshold depending on current RPM;"v",      1,     0,   0.0,    10,   2
	float[ENGINE_NOISE_CURVE_SIZE] knockNoiseRpmBins;;"RPM",      1,     0,   0.0,    18000,   2

	float throttlePedalUpVoltage;;"voltage",      1,     0,    -6,   6,      2
	float throttlePedalWOTVoltage;+Pedal in the floor;"voltage",      1,     0,    -6,   6,      2
	pin_output_mode_e stepperDirectionPinMode;
	
	int16_t startUpFuelPumpDuration;+on ECU start turn fuel pump on to build fuel pressure;"seconds",        1,     0,  0,    6000,  0
	int16_t idlePidRpmDeadZone;If RPM is close enough let's leave IAC alone;"RPM",        1,     0,  0,    1000,  0
	
	
	float[CLT_CURVE_SIZE] cltIdleRpmBins;CLT-based target RPM for automatic idle controller;"C",        1,     0,   -100.0,    250.0,  2
	float[CLT_CURVE_SIZE] cltIdleRpm;See idleRpmPid;"",      1,     0,      0.0,    8000.0,   0
	
	float targetVBatt;set targetvbatt VOLTS;"Volts",      1,      0,       0,30,      1
	float alternatorOffAboveTps;Turn off alternator output above specified TPS;"%",  1,      0,       0, 200,      2
	float startOfCrankingPrimingPulse;;"ms",        1,     0,    0, 200,     1
	int16_t afterCrankingIACtaperDuration;;"cycles",        1,     0,  0,    5000,  0
	
	int16_t iacByTpsTaper;Extra IAC, in percent between 0 and 100, tapered between zero and idle deactivation TPS value;"percent",        1,     0,  0,    500,  0
	brain_pin_e LIS302DLCsPin; 
	
	int tpsAccelLength;;"cycles",        1,     0,    1, 200,     0
	float tpsAccelEnrichmentThreshold;;"roc",        1,     0,    0, 200,     3
	float vvtOffset;set vvt_offset X;"value",      1,      0,       -720, 1000,      1
	
	int engineLoadAccelLength;;"cycles",        1,     0,    1, 200,     0
	
	float engineLoadDecelEnleanmentThreshold;;"roc",        1,     0,    0, 200,     3
	float engineLoadDecelEnleanmentMultiplier;;"coeff",        1,     0,    0, 200,     3
	float engineLoadAccelEnrichmentThreshold;;"roc",        1,     0,    0, 200,     3
	float engineLoadAccelEnrichmentMultiplier;;"coeff",        1,     0,    0, 200,     3


	brain_pin_e fatalErrorPin;RED led on Discovery by default. TODO: start using this property
	brain_pin_e warninigPin;TODO: start using this property
	brain_pin_e configResetPin;
	uint32_t uartConsoleSerialSpeed;;"BPs",      1,      0,       0,1000000,      0
	float tpsDecelEnleanmentThreshold;;"roc",        1,     0,    0, 200,     3
	float tpsDecelEnleanmentMultiplier;;"coeff",        1,     0,    0, 200,     3
	float slowAdcAlpha;+ExpAverage alpha coefficient;"coeff",        1,     0,    0, 200,     3
	debug_mode_e debugMode;set debug_mode X
	brain_pin_e[AUX_DIGITAL_VALVE_COUNT iterate] auxValves

	float[WARMUP_TARGET_AFR_SIZE] warmupTargetAfrBins;CLT-based target AFR for PID-based control;"C",        1,     0,   -100.0,    250.0,  2
	float[WARMUP_TARGET_AFR_SIZE] warmupTargetAfr;;"AFR",      1,     0,      0.0,    20.0,   2
	float warmupAfrThreshold;;"tempterature",        1,     0,    0, 200,     3

	float boostCutPressure;kPa value at which we need to cut fuel and spark, 0 if not enabled;"kPa",        1,     0,    0, 500,     0

float[MAP_ACCEL_TAPER] mapAccelTaperBins;;"counter",      1,     0,   0.0,    300,   0
float[MAP_ACCEL_TAPER] mapAccelTaperMult;;"mult",      1,     0,   0.0,    300,   2

	brain_pin_e dizzySparkOutputPin;+This implementation makes a pulse every time one of the coils is charged, using coil dwell for pulse width. See also tachOutputPin
	pin_output_mode_e dizzySparkOutputPinMode;
	adc_channel_e[FSIO_ANALOG_INPUT_COUNT iterate] fsioAdc;todo: rename to fsioAnalogInputs
	float fixedTiming;Fixed timing, useful for TDC testing;"deg",      1,     0,   -720,    720,   2
	float mapLowValueVoltage;MAP voltage for low point;"v",      1,     0,   0.0,    10,   2 
	float mapHighValueVoltage;MAP voltage for low point;"v",      1,     0,   0.0,    10,   2 
	float egoValueShift;EGO value correction;"value",      1,     0,   -10.0,    10,   2 
	brain_input_pin_e camInput;
	int crankingIACposition;+IAC position during cranking;"percent",      1,     0,   -100.0,    100,    
	float tChargeMinRpmMinTps;;"mult",        1,     0,  0,    3,  4
	float tChargeMinRpmMaxTps;;"mult",        1,     0,  0,    3,  4
	float tChargeMaxRpmMinTps;;"mult",        1,     0,  0,    3,  4
	float tChargeMaxRpmMaxTps;;"mult",        1,     0,  0,    3,  4   
	brain_pin_e[AUX_PID_COUNT iterate] auxPidPins;
	fsio_pwm_freq_t[AUX_PID_COUNT iterate] auxPidFrequency;
	int alternatorPwmFrequency;;"Hz",        1,     0,  0,    3000.0,  0
	mass_storage_e storageMode;
	spi_device_e cj125SpiDevice;
	pin_output_mode_e cj125CsPinMode;
	float[NARROW_BAND_WIDE_BAND_CONVERSION_SIZE] narrowToWideOxygenBins;Narrow Band WBO Approximation;"V",        1,     0,   -10.0,    10.0,  3
	float[NARROW_BAND_WIDE_BAND_CONVERSION_SIZE] narrowToWideOxygen;;"ratio",      1,     0,      -40.0,    40.0,   2
	vvt_mode_e vvtMode;set vvt_mode X
	bi_quard_s biQuad;
	float[CLT_TIMING_CURVE_SIZE] cltTimingBins;CLT-based timing correction;"C",        1,     0,   -100.0,    250.0,  1
	float[CLT_TIMING_CURVE_SIZE] cltTimingExtra;;"degree",      1,     0,      -400.0,    400.0,   0
	int nbVvtIndex;;"index",        1,     0,  0,    4.0,  0
	float autoTuneCltThreshold;
	float autoTuneTpsRocThreshold;
	float autoTuneTpsQuietPeriod;
	float postCrankingTargetClt;;"C",        1,     0,  0,    100,  0
	float postCrankingFactor;Fuel multiplier taper, see also postCrankingDurationSec;"mult",        1,     0,  0,    100,  4
	float postCrankingDurationSec;See also postCrankingFactor;"seconds",        1,     0,  0,    100,  2
	ThermistorConf auxTempSensor1;todo: finish implementation #332
	ThermistorConf auxTempSensor2;todo: finish implementation #332
	int16_t fuelClosedLoopCltThreshold;;"C",        1,     0,  0,    100,  0
	int16_t fuelClosedLoopTpsThreshold;;"%",        1,     0,  0,    100,  0
	int16_t fuelClosedLoopRpmThreshold;;"rpm",        1,     0,  0,    5000,  0
	int16_t etbFreq;;"Hz",      1,     0,    0, 1500,      0
	pid_s fuelClosedLoopPid;
	float fuelClosedLoopAfrHighThreshold;;"ratio",        1,     0,  0,    100,  1
	pin_mode_e stepperEnablePinMode;
	adc_channel_e cj125ua;lampda input
	adc_channel_e cj125ur;heater input
	
	custom cfg_float_t_1f 4 scalar,  F32,   @OFFSET@, 		"Val",	   1,	   0,       -20000000, 20000000,	  1
	cfg_float_t_1f[IGNITION_PIN_COUNT iterate] timing_offset_cylinder;

	pin_input_mode_e brakePedalPinMode;
	float idlePidActivationTime;;"seconds",        1,     0,  0,    60,  1


spi_device_e sdCardSpiDevice;
	pin_mode_e spi3SckMode;
	pin_mode_e spi3MosiMode;
	pin_mode_e spi3MisoMode;
	pin_mode_e spi1SckMode;
	pin_mode_e spi1MosiMode;
	pin_mode_e spi1MisoMode;
brain_pin_e brakePedalPin
	pid_s[AUX_PID_COUNT iterate] auxPid;

	oil_pressure_config_s oilPressure;

spi_device_e accelerometerSpiDevice;
	float[FSIO_CURVE_16] fsioCurve1Bins;;"x",        1,     0,   -999,    1000.0,  3
	float[FSIO_CURVE_16] fsioCurve1;;"y",      1,     0,      -999,    1000.0,   3
	float[FSIO_CURVE_16] fsioCurve2Bins;;"x",        1,     0,   -999,    1000.0,  3
	float[FSIO_CURVE_16] fsioCurve2;;"y",      1,     0,      -999,    1000.0,   3
	float[FSIO_CURVE_8] fsioCurve3Bins;;"x",        1,     0,   -999,    1000.0,  3
	float[FSIO_CURVE_8] fsioCurve3;;"y",      1,     0,      -999,    1000.0,   3
	float[FSIO_CURVE_8] fsioCurve4Bins;;"x",        1,     0,   -999,    1000.0,  3
	float[FSIO_CURVE_8] fsioCurve4;;"y",      1,     0,      -999,    1000.0,   3
	int[794] unusedEnd;
	

end_struct

engine_configuration_s engineConfiguration;

float[CLT_CRANKING_CURVE_SIZE] cltCrankingCorrBins;CLT-based cranking position multiplier for simple manual idle controller;"C",        1,     0,   -100.0,    250.0,  2
float[CLT_CRANKING_CURVE_SIZE] cltCrankingCorr    ;CLT-based cranking position multiplier for simple manual idle controller;"%",      1,     0,      0.0,    500.0,   2

float[IDLE_ADVANCE_CURVE_SIZE] idleAdvanceBins;Optional timing advance table for Idle (see useSeparateAdvanceForIdle);"RPM",      1,     0,   0.0,    18000,   2
float[IDLE_ADVANCE_CURVE_SIZE] idleAdvance    ;Optional timing advance table for Idle (see useSeparateAdvanceForIdle);"deg",      1,     0,     -20, 90,    2
float[IDLE_VE_CURVE_SIZE] idleVeBins;Optional VE table for Idle (see useSeparateVEForIdle);"RPM",      1,     0,   0.0,    18000,   2
float[IDLE_VE_CURVE_SIZE] idleVe;    Optional VE table for Idle (see useSeparateVEForIdle);,"%", 1, 0, 0, 999.0, 2

le_formula_t[FSIO_COMMAND_COUNT iterate] fsioFormulas;
	le_formula_t timingMultiplier;
	le_formula_t timingAdditive;

float[CLT_CURVE_SIZE] cltFuelCorrBins;;"C",        1,     0,   -100.0,    250.0,  2
float[CLT_CURVE_SIZE] cltFuelCorr;;"%",      1,     0,      0.0,    500.0,   2

float[IAT_CURVE_SIZE] iatFuelCorrBins;;"C",        1,     0,   -100.0,    250.0,   2
float[IAT_CURVE_SIZE] iatFuelCorr;;"%",      1,     0,      0.0,    500.0,   2

	float[CRANKING_CURVE_SIZE] crankingFuelCoef;;"%",      1,     0,      0.0,    700.0,   2
	float[CRANKING_CURVE_SIZE] crankingFuelBins;;"C",        1,     0,    -80.0,    170.0,  2

	float[CRANKING_CURVE_SIZE] crankingCycleCoef;;"%",      1,     0,      0.0,    500.0,   2
	float[CRANKING_CURVE_SIZE] crankingCycleBins;;"counter",        1,     0,    -80.0,    170.0,  2

float[CLT_CURVE_SIZE] cltIdleCorrBins;CLT-based idle position multiplier for simple manual idle controller, or target RPM multiplier for PID-based idle;"C",        1,     0,   -100.0,    250.0,  2
float[CLT_CURVE_SIZE] cltIdleCorr;    CLT-based idle position multiplier for simple manual idle controller, or target RPM multiplier for PID-based idle;"%",      1,     0,      0.0,    1000.0,   2

float[MAF_DECODING_COUNT] mafDecoding;kg/hour value.\nBy the way 2.081989116 kg/h = 1 ft³/m;"kg/hour", 1, 0, -500.0, 4000.0, 2
float[MAF_DECODING_COUNT] mafDecodingBins;; "V", 1, 0, -5.0, 150.0, 2

angle_table_t ignitionIatCorrTable;
float[IGN_LOAD_COUNT] ignitionIatCorrLoadBins;;"Temperature",   1,   0.0,        0,  300.0,   2
float[IGN_RPM_COUNT] ignitionIatCorrRpmBins;;"RPM",	   1,   0.0,        0,  18000.0, 2

angle_table_t injectionPhase;
float[FUEL_LOAD_COUNT] injPhaseLoadBins;;"Load",   1,   0.0,        0,  300.0,   2
float[FUEL_RPM_COUNT] injPhaseRpmBins;;"RPM",	   1,   0.0,        0,  18000.0, 2

fuel_table_t fuelTable;
float[FUEL_LOAD_COUNT] fuelLoadBins;;"V",	   1,      0,      0.0,  300.0,   2
float[FUEL_RPM_COUNT] fuelRpmBins;RPM is float and not integer in order to use unified methods for interpolation;"RPM",	   1,      0,      0.0,  25500.0,   2

ignition_table_t ignitionTable;
float[IGN_LOAD_COUNT] ignitionLoadBins;;"Load",   1,   0.0,        0,  300.0,   2
float[IGN_RPM_COUNT] ignitionRpmBins;;"RPM",	   1,   0.0,        0,  18000.0, 2

ve_table_t veTable;
float[FUEL_LOAD_COUNT] veLoadBins;;"kPa",	1,   0.0,        0,  300.0,   2
float[FUEL_RPM_COUNT] veRpmBins;;"RPM",	   1,   0.0,        0,  18000.0, 2

afr_table_t afrTable;		
float[FUEL_LOAD_COUNT] afrLoadBins;;"",	1,   0.0,        0,  300.0,   2
float[FUEL_RPM_COUNT] afrRpmBins;;"RPM",	   1,   0.0,        0,  18000.0, 2

! ve_table_t ve2Table;
! float[FUEL_LOAD_COUNT] ve2LoadBins;;"kPa",	1,   0.0,        0,  300.0,   2
! float[FUEL_RPM_COUNT] ve2RpmBins;;"RPM",	   1,   0.0,        0,  18000.0, 2

tps_tps_table_t tpsTpsAccelTable;
float[TPS_TPS_ACCEL_TABLE] tpsTpsAccelFromRpmBins;;"from",	   1,      0,      0.0,  30000.0,   2
float[TPS_TPS_ACCEL_TABLE] tpsTpsAccelToRpmBins;RPM is float and not integer in order to use unified methods for interpolation;"to",	   1,      0,      0.0,  25500.0,   2

fsio_table_8x8_f32t fsioTable1;
float[FSIO_TABLE_8] fsioTable1LoadBins;;"L",	   1,      0,      0.0,  30000.0,   2
float[FSIO_TABLE_8] fsioTable1RpmBins;RPM is float and not integer in order to use unified methods for interpolation;"RPM",	   1,      0,      0.0,  25500.0,   2

fsio_table_8x8_u8t fsioTable2;
float[FSIO_TABLE_8] fsioTable2LoadBins;;"L",	   1,      0,      0.0,  255,   0
float[FSIO_TABLE_8] fsioTable2RpmBins;RPM is float and not integer in order to use unified methods for interpolation;"RPM",	   1,      0,      0.0,  25500.0,   2

fsio_table_8x8_u8t fsioTable3;
float[FSIO_TABLE_8] fsioTable3LoadBins;;"L",	   1,      0,      0.0,  255,   0
float[FSIO_TABLE_8] fsioTable3RpmBins;RPM is float and not integer in order to use unified methods for interpolation;"RPM",	   1,      0,      0.0,  25500.0,   2

fsio_table_8x8_u8t fsioTable4;
float[FSIO_TABLE_8] fsioTable4LoadBins;;"L",	   1,      0,      0.0,  255,   0
float[FSIO_TABLE_8] fsioTable4RpmBins;RPM is float and not integer in order to use unified methods for interpolation;"RPM",	   1,      0,      0.0,  25500.0,   2

end_struct

#define GAUGE_NAME_VERSION "firmware"
#define GAUGE_NAME_VVT "VVT postion"
#define GAUGE_NAME_TIMING_ADVANCE "timing"
#define GAUGE_NAME_VVS "Vehicle Speed"
#define GAUGE_NAME_VBAT "VBatt"
#define GAUGE_NAME_ENGINE_LOAD "Engine Load"
#define GAUGE_NAME_CPU_TEMP "CPU Temperature"

#define GAUGE_NAME_ACCEL_X "Acceleration: X"
#define GAUGE_NAME_ACCEL_Y "Acceleration: Y"
#define GAUGE_NAME_ACCEL_Z "Acceleration: Z"


#define INDICATOR_NAME_CLUTCH_UP "clutch: up"
#define INDICATOR_NAME_CLUTCH_DOWN "clutch: down"
#define INDICATOR_NAME_BRAKE_DOWN "brake: down"


#define GAUGE_NAME_WARNING_LAST "warning: last"
#define GAUGE_NAME_WARNING_COUNTER "warning: counter"


#define GAUGE_NAME_KNOCK_LEVEL "knock: current level"
#define GAUGE_NAME_KNOCK_COUNTER "knock: counter"


#define GAUGE_NAME_INJECTOR_LAG "fuel: injector lag"
#define GAUGE_NAME_FUEL_TPS_EXTRA "fuel: TPS acceleration extra fuel"
#define GAUGE_NAME_FUEL_EL_EXTRA "fuel: engine load acceleration extra fuel"
#define GAUGE_NAME_FUEL_CLT_CORR "fuel: CLT correction"
#define GAUGE_NAME_FUEL_IAT_CORR "fuel: IAT correction"
#define GAUGE_NAME_FUEL_VR "fuel: VE"
#define GAUGE_NAME_FUEL_RUNNING "fuel: running"
#define GAUGE_NAME_FUEL_LAST_INJECTION  "fuel: last injection"
#define GAUGE_NAME_FUEL_BASE "fuel: base"
#define GAUGE_NAME_FUEL_PID_CORR "fuel: correction"

#define GAUGE_NAME_FUEL_INJ_DUTY "fuel: injector duty cycle"
#define GAUGE_NAME_TCHARGE "fuel: SD tCharge"
#define GAUGE_NAME_TARGET_AFR "fuel: target AFR"
#define GAUGE_NAME_AFR "Air/Fuel Ratio"
#define GAUGE_NAME_IAC "Idle Air Valve"

#define GAUGE_NAME_DEBUG_F1 "debug f1"
#define GAUGE_NAME_DEBUG_F2 "debug f2: iTerm"
#define GAUGE_NAME_DEBUG_F3 "debug f3: prevError"
#define GAUGE_NAME_DEBUG_F4 "debug f4: iParam"
#define GAUGE_NAME_DEBUG_F5 "debug f5: dParam"
#define GAUGE_NAME_DEBUG_F6 "debug f6: dTerm"
#define GAUGE_NAME_DEBUG_F7 "debug f7"

#define GAUGE_NAME_DEBUG_I1 "debug i1: pParam"
#define GAUGE_NAME_DEBUG_I2 "debug i2: offset"
#define GAUGE_NAME_DEBUG_I3 "debug i3"



#define GAUGE_NAME_DWELL_DUTY "dwell: coil duty cycle"

#define GAUGE_COIL_DWELL_TIME "dwell: coil charge time"
